#include "reorder_buffer.h"

// TODO: Re-implement with LVT based multi-ported RAM
/*
Per-entry:

3reads/1writes
PC[30];

1reads/1writes
struct rob {
	uop0[SIZEOF_UOP_T];
	dreg0[5];
	preg0[6];
	ppreg0[6];
	uop1[SIZEOF_UOP_T];
	dreg1[5];
	preg1[6];
	ppreg1[6];
};

1reads/5writes
struct rob_exec {
	valid0;
	completed0;
	valid1;
	completed1;
};
Oldest branch/jump exception instructions:
1reads/1writes
valid;
struct recovery_manager_t {
	ptr[N];
	cause[SIZEOF_CAUSE_T];
	taken;
	target[32];
};
*/
module reorder_buffer {
	reorder_buffer_t reg rob0 = 0;
	reorder_buffer_t reg rob1 = 0;
	reorder_buffer_t reg rob2 = 0;
	reorder_buffer_t reg rob3 = 0;
	reorder_buffer_t reg rob4 = 0;
	reorder_buffer_t reg rob5 = 0;
	reorder_buffer_t reg rob6 = 0;
	reorder_buffer_t reg rob7 = 0;
	reg tail[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES+1] = 0;
	reg head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES+1] = 0;
	wire commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES+1];
	wire next_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES+1];
	wire next_tail[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES+1];
	reorder_buffer_t wire head_entry;
	
	next_tail = tail + 1;
	next_head = head + 1;
	head_ptr = head << 1;
	head_o = head;
	tail_o = tail;
	func issue {
		reorder_buffer_t wire new_entry;

		new_entry.PC = PC;
		new_entry.valid0 = valid0;
		new_entry.uop0 = uop0;
		new_entry.dreg0 = dreg0;
		new_entry.preg0 = preg0;
		new_entry.ppreg0 = ppreg0;
		new_entry.cause0 = cause0;
		new_entry.completed0 = valid0;
		new_entry.valid1 = valid1;
		new_entry.uop1 = uop1;
		new_entry.dreg1 = dreg1;
		new_entry.preg1 = preg1;
		new_entry.ppreg1 = ppreg1;
		new_entry.cause1 = cause1;
		new_entry.completed1 = valid1;
#ifdef ENABLE_DEBUG
		new_entry.inst0 = inst0;
		new_entry.inst1 = inst1;
#endif

		if(!flush) {
			any {
				tail[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 0: rob0 := new_entry;
				tail[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 1: rob1 := new_entry;
				tail[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 2: rob2 := new_entry;
				tail[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 3: rob3 := new_entry;
				tail[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 4: rob4 := new_entry;
				tail[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 5: rob5 := new_entry;
				tail[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 6: rob6 := new_entry;
				tail[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 7: rob7 := new_entry;
			}
			tail := next_tail;
		}
		return tail  << 1;
	}
	any {
		commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 0: head_entry = rob0;
		commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 1: head_entry = rob1;
		commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 2: head_entry = rob2;
		commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 3: head_entry = rob3;
		commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 4: head_entry = rob4;
		commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 5: head_entry = rob5;
		commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 6: head_entry = rob6;
		commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 7: head_entry = rob7;
	}
	if((head_entry.valid0 || head_entry.valid1) && (!head_entry.completed0 && !head_entry.completed1)) {
		commitable();
	}
	if(rewind) {
		commit_head = tail;
	} else {
		commit_head = head;
	}
	func commit {
		if(!flush) {
			// TODO:
			any {
				commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 0: rob0 := 0;
				commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 1: rob1 := 0;
				commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 2: rob2 := 0;
				commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 3: rob3 := 0;
				commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 4: rob4 := 0;
				commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 5: rob5 := 0;
				commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 6: rob6 := 0;
				commit_head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == 7: rob7 := 0;
			}
			if(rewind) {
				tail := tail - 1;
			} else {
				head := next_head;
			}
		}
		return head_entry;
	}
    if(!flush) {
        if((tail[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0] == head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES-1:0])
            && (tail[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES] != head[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES])) {
            full();
        }
    }
	func complete_alu0 {
		if(!flush) {
			any {
				complete_alu0_ptr ==  0: {rob0.completed0 := 0; rob0.target0 := complete_alu0_target; rob0.taken0 := complete_alu0_taken;}
				complete_alu0_ptr ==  1: {rob0.completed1 := 0; rob0.target1 := complete_alu0_target; rob0.taken1 := complete_alu0_taken;}
				complete_alu0_ptr ==  2: {rob1.completed0 := 0; rob1.target0 := complete_alu0_target; rob1.taken0 := complete_alu0_taken;}
				complete_alu0_ptr ==  3: {rob1.completed1 := 0; rob1.target1 := complete_alu0_target; rob1.taken1 := complete_alu0_taken;}
				complete_alu0_ptr ==  4: {rob2.completed0 := 0; rob2.target0 := complete_alu0_target; rob2.taken0 := complete_alu0_taken;}
				complete_alu0_ptr ==  5: {rob2.completed1 := 0; rob2.target1 := complete_alu0_target; rob2.taken1 := complete_alu0_taken;}
				complete_alu0_ptr ==  6: {rob3.completed0 := 0; rob3.target0 := complete_alu0_target; rob3.taken0 := complete_alu0_taken;}
				complete_alu0_ptr ==  7: {rob3.completed1 := 0; rob3.target1 := complete_alu0_target; rob3.taken1 := complete_alu0_taken;}
				complete_alu0_ptr ==  8: {rob4.completed0 := 0; rob4.target0 := complete_alu0_target; rob4.taken0 := complete_alu0_taken;}
				complete_alu0_ptr ==  9: {rob4.completed1 := 0; rob4.target1 := complete_alu0_target; rob4.taken1 := complete_alu0_taken;}
				complete_alu0_ptr == 10: {rob5.completed0 := 0; rob5.target0 := complete_alu0_target; rob5.taken0 := complete_alu0_taken;}
				complete_alu0_ptr == 11: {rob5.completed1 := 0; rob5.target1 := complete_alu0_target; rob5.taken1 := complete_alu0_taken;}
				complete_alu0_ptr == 12: {rob6.completed0 := 0; rob6.target0 := complete_alu0_target; rob6.taken0 := complete_alu0_taken;}
				complete_alu0_ptr == 13: {rob6.completed1 := 0; rob6.target1 := complete_alu0_target; rob6.taken1 := complete_alu0_taken;}
				complete_alu0_ptr == 14: {rob7.completed0 := 0; rob7.target0 := complete_alu0_target; rob7.taken0 := complete_alu0_taken;}
				complete_alu0_ptr == 15: {rob7.completed1 := 0; rob7.target1 := complete_alu0_target; rob7.taken1 := complete_alu0_taken;}
			}
		}
	}
	func complete_alu1 {
		if(!flush) {
			any {
				complete_alu1_ptr ==  0: {rob0.completed0 := 0; rob0.target0 := complete_alu1_target; rob0.taken0 := complete_alu1_taken;}
				complete_alu1_ptr ==  1: {rob0.completed1 := 0; rob0.target1 := complete_alu1_target; rob0.taken1 := complete_alu1_taken;}
				complete_alu1_ptr ==  2: {rob1.completed0 := 0; rob1.target0 := complete_alu1_target; rob1.taken0 := complete_alu1_taken;}
				complete_alu1_ptr ==  3: {rob1.completed1 := 0; rob1.target1 := complete_alu1_target; rob1.taken1 := complete_alu1_taken;}
				complete_alu1_ptr ==  4: {rob2.completed0 := 0; rob2.target0 := complete_alu1_target; rob2.taken0 := complete_alu1_taken;}
				complete_alu1_ptr ==  5: {rob2.completed1 := 0; rob2.target1 := complete_alu1_target; rob2.taken1 := complete_alu1_taken;}
				complete_alu1_ptr ==  6: {rob3.completed0 := 0; rob3.target0 := complete_alu1_target; rob3.taken0 := complete_alu1_taken;}
				complete_alu1_ptr ==  7: {rob3.completed1 := 0; rob3.target1 := complete_alu1_target; rob3.taken1 := complete_alu1_taken;}
				complete_alu1_ptr ==  8: {rob4.completed0 := 0; rob4.target0 := complete_alu1_target; rob4.taken0 := complete_alu1_taken;}
				complete_alu1_ptr ==  9: {rob4.completed1 := 0; rob4.target1 := complete_alu1_target; rob4.taken1 := complete_alu1_taken;}
				complete_alu1_ptr == 10: {rob5.completed0 := 0; rob5.target0 := complete_alu1_target; rob5.taken0 := complete_alu1_taken;}
				complete_alu1_ptr == 11: {rob5.completed1 := 0; rob5.target1 := complete_alu1_target; rob5.taken1 := complete_alu1_taken;}
				complete_alu1_ptr == 12: {rob6.completed0 := 0; rob6.target0 := complete_alu1_target; rob6.taken0 := complete_alu1_taken;}
				complete_alu1_ptr == 13: {rob6.completed1 := 0; rob6.target1 := complete_alu1_target; rob6.taken1 := complete_alu1_taken;}
				complete_alu1_ptr == 14: {rob7.completed0 := 0; rob7.target0 := complete_alu1_target; rob7.taken0 := complete_alu1_taken;}
				complete_alu1_ptr == 15: {rob7.completed1 := 0; rob7.target1 := complete_alu1_target; rob7.taken1 := complete_alu1_taken;}
			}
		}
	}
	func complete_lsu0 {
		if(!flush) {
			any {
				complete_lsu0_ptr ==  0: rob0.completed0 := 0;
				complete_lsu0_ptr ==  1: rob0.completed1 := 0;
				complete_lsu0_ptr ==  2: rob1.completed0 := 0;
				complete_lsu0_ptr ==  3: rob1.completed1 := 0;
				complete_lsu0_ptr ==  4: rob2.completed0 := 0;
				complete_lsu0_ptr ==  5: rob2.completed1 := 0;
				complete_lsu0_ptr ==  6: rob3.completed0 := 0;
				complete_lsu0_ptr ==  7: rob3.completed1 := 0;
				complete_lsu0_ptr ==  8: rob4.completed0 := 0;
				complete_lsu0_ptr ==  9: rob4.completed1 := 0;
				complete_lsu0_ptr == 10: rob5.completed0 := 0;
				complete_lsu0_ptr == 11: rob5.completed1 := 0;
				complete_lsu0_ptr == 12: rob6.completed0 := 0;
				complete_lsu0_ptr == 13: rob6.completed1 := 0;
				complete_lsu0_ptr == 14: rob7.completed0 := 0;
				complete_lsu0_ptr == 15: rob7.completed1 := 0;
			}
		}
	}
	func readPC0 {
		// TODO:
		any {
			readPC0_ptr ==  0: return {rob0.PC, 2'b00};
			readPC0_ptr ==  1: return {rob0.PC, 2'b00}+4;
			readPC0_ptr ==  2: return {rob1.PC, 2'b00};
			readPC0_ptr ==  3: return {rob1.PC, 2'b00}+4;
			readPC0_ptr ==  4: return {rob2.PC, 2'b00};
			readPC0_ptr ==  5: return {rob2.PC, 2'b00}+4;
			readPC0_ptr ==  6: return {rob3.PC, 2'b00};
			readPC0_ptr ==  7: return {rob3.PC, 2'b00}+4;
			readPC0_ptr ==  8: return {rob4.PC, 2'b00};
			readPC0_ptr ==  9: return {rob4.PC, 2'b00}+4;
			readPC0_ptr == 10: return {rob5.PC, 2'b00};
			readPC0_ptr == 11: return {rob5.PC, 2'b00}+4;
			readPC0_ptr == 12: return {rob6.PC, 2'b00};
			readPC0_ptr == 13: return {rob6.PC, 2'b00}+4;
			readPC0_ptr == 14: return {rob7.PC, 2'b00};
			readPC0_ptr == 15: return {rob7.PC, 2'b00}+4;
		}
	}
	func readPC1 {
		// TODO:
		any {
			readPC1_ptr ==  0: return {rob0.PC, 2'b00};
			readPC1_ptr ==  1: return {rob0.PC, 2'b00}+4;
			readPC1_ptr ==  2: return {rob1.PC, 2'b00};
			readPC1_ptr ==  3: return {rob1.PC, 2'b00}+4;
			readPC1_ptr ==  4: return {rob2.PC, 2'b00};
			readPC1_ptr ==  5: return {rob2.PC, 2'b00}+4;
			readPC1_ptr ==  6: return {rob3.PC, 2'b00};
			readPC1_ptr ==  7: return {rob3.PC, 2'b00}+4;
			readPC1_ptr ==  8: return {rob4.PC, 2'b00};
			readPC1_ptr ==  9: return {rob4.PC, 2'b00}+4;
			readPC1_ptr == 10: return {rob5.PC, 2'b00};
			readPC1_ptr == 11: return {rob5.PC, 2'b00}+4;
			readPC1_ptr == 12: return {rob6.PC, 2'b00};
			readPC1_ptr == 13: return {rob6.PC, 2'b00}+4;
			readPC1_ptr == 14: return {rob7.PC, 2'b00};
			readPC1_ptr == 15: return {rob7.PC, 2'b00}+4;
		}
	}
	func flush {
		head := 0;
		tail := 0;
		rob0 := 0;
		rob1 := 0;
		rob2 := 0;
		rob3 := 0;
		rob4 := 0;
		rob5 := 0;
		rob6 := 0;
		rob7 := 0;
	}
}
