#include "reorder_buffer.h"
#include "reorder_buffer_exec.h"
#include "uops.h"

module reorder_buffer {
    mem rob[NUMBER_OF_ROB][SIZEOF_REORDER_BUFFER_T] = {0};
    reorder_buffer_exec rob_exec_stat[2];
    mem rob_busy0[NUMBER_OF_ROB][1] = {0};
    mem rob_busy1[NUMBER_OF_ROB][1] = {0};
    mem rob_valid0[NUMBER_OF_ROB][1] = {0};
    mem rob_valid1[NUMBER_OF_ROB][1] = {0};

    reg tail[LOG2_ROB_NUM_OF_ENTRIES+1] = 0;
    reg head[LOG2_ROB_NUM_OF_ENTRIES+1] = 0;
    wire next_tail[LOG2_ROB_NUM_OF_ENTRIES+1];
    wire next_head[LOG2_ROB_NUM_OF_ENTRIES+1];
    wire tail_idx[LOG2_ROB_NUM_OF_ENTRIES];
    wire head_idx[LOG2_ROB_NUM_OF_ENTRIES];
    integer i_;

    next_tail = tail + 1;
    next_head = head + 1;
    tail_idx = tail[LOG2_ROB_NUM_OF_ENTRIES-1:0];
    head_idx = head[LOG2_ROB_NUM_OF_ENTRIES-1:0];

    func issue {
        if(!flush) {
            reorder_buffer_t wire rob_new_entry;

            rob_valid0[tail_idx] := valid0;
            rob_valid1[tail_idx] := valid1;
            rob_busy0[tail_idx] := valid0;
            rob_busy1[tail_idx] := valid1;

            rob_new_entry.PC0 = pc0;
            rob_new_entry.Inst0 = inst0;
            rob_new_entry.uOp0 = uop0;
            rob_new_entry.CSR_Value0 = csr_value0;
            rob_new_entry.PC1 = pc1;
            rob_new_entry.Inst1 = inst1;
            rob_new_entry.uOp1 = uop1;
            rob_new_entry.CSR_Value1 = csr_value1;

            rob[tail_idx] := rob_new_entry;
            rob_exec_stat[0].issue(tail_idx, 0);
            rob_exec_stat[1].issue(tail_idx, 0);

            tail := next_tail;
            return tail<<1;
        }
    }
    func flush {
        tail := 0;
        head := 0;
        generate(i_ = 0; i_ < NUMBER_OF_ROB; i_++) {
            rob_valid0[i_] := 0;
            rob_valid1[i_] := 0;
            rob_busy0[i_] := 0;
            rob_busy1[i_] := 0;
        }
    }
    func read_operandA {
        wire read_operandA_bank_sel;
        wire read_operandA_addr[LOG2_ROB_NUM_OF_ENTRIES];
        reorder_buffer_exec_t wire read_operandA_exec_stat;

        if(!flush) {
            read_operandA_bank_sel = read_operandA_id[0];
            read_operandA_addr = read_operandA_id[ROB_TAG_SIZE-1:1];
            if(read_operandA_bank_sel == 0) {
                read_operandA_exec_stat = rob_exec_stat[0].read_operandA(read_operandA_addr);
                read_operandA_val = read_operandA_exec_stat.Value;
                return rob_busy0[read_operandA_addr];
            } else if(read_operandA_bank_sel == 1) {
                read_operandA_exec_stat = rob_exec_stat[1].read_operandA(read_operandA_addr);
                read_operandA_val = read_operandA_exec_stat.Value;
                return rob_busy1[read_operandA_addr];
            }
        }
    }
    func read_operandB {
        wire read_operandB_bank_sel;
        wire read_operandB_addr[LOG2_ROB_NUM_OF_ENTRIES];
        reorder_buffer_exec_t wire read_operandB_exec_stat;

        if(!flush) {
            read_operandB_bank_sel = read_operandB_id[0];
            read_operandB_addr = read_operandB_id[ROB_TAG_SIZE-1:1];
            if(read_operandB_bank_sel == 0) {
                read_operandB_exec_stat = rob_exec_stat[0].read_operandB(read_operandB_addr);
                read_operandB_val = read_operandB_exec_stat.Value;
                return rob_busy0[read_operandB_addr];
            } else if(read_operandB_bank_sel == 1) {
                read_operandB_exec_stat = rob_exec_stat[1].read_operandB(read_operandB_addr);
                read_operandB_val = read_operandB_exec_stat.Value;
                return rob_busy1[read_operandB_addr];
            }
        }
    }
    func read_operandC {
        wire read_operandC_bank_sel;
        wire read_operandC_addr[LOG2_ROB_NUM_OF_ENTRIES];
        reorder_buffer_exec_t wire read_operandC_exec_stat;

        if(!flush) {
            read_operandC_bank_sel = read_operandC_id[0];
            read_operandC_addr = read_operandC_id[ROB_TAG_SIZE-1:1];
            if(read_operandC_bank_sel == 0) {
                read_operandC_exec_stat = rob_exec_stat[0].read_operandC(read_operandC_addr);
                read_operandC_val = read_operandC_exec_stat.Value;
                return rob_busy0[read_operandC_addr];
            } else if(read_operandC_bank_sel == 1) {
                read_operandC_exec_stat = rob_exec_stat[1].read_operandC(read_operandC_addr);
                read_operandC_val = read_operandC_exec_stat.Value;
                return rob_busy1[read_operandC_addr];
            }
        }
    }
    func read_operandD {
        wire read_operandD_bank_sel;
        wire read_operandD_addr[LOG2_ROB_NUM_OF_ENTRIES];
        reorder_buffer_exec_t wire read_operandD_exec_stat;

        if(!flush) {
            read_operandD_bank_sel = read_operandD_id[0];
            read_operandD_addr = read_operandD_id[ROB_TAG_SIZE-1:1];
            if(read_operandD_bank_sel == 0) {
                read_operandD_exec_stat = rob_exec_stat[0].read_operandD(read_operandD_addr);
                read_operandD_val = read_operandD_exec_stat.Value;
                return rob_busy0[read_operandD_addr];
            } else if(read_operandD_bank_sel == 1) {
                read_operandD_exec_stat = rob_exec_stat[1].read_operandD(read_operandD_addr);
                read_operandD_val = read_operandD_exec_stat.Value;
                return rob_busy1[read_operandD_addr];
            }
        }
    }
    func CDB0 {
        wire CDB0_bank_sel;
        wire CDB0_addr[LOG2_ROB_NUM_OF_ENTRIES];
        reorder_buffer_exec_t wire CDB0_exec_stat;

        if(!flush) {
            CDB0_bank_sel = CDB0Id[0];
            CDB0_addr = CDB0Id[ROB_TAG_SIZE-1:1];
            CDB0_exec_stat.Value = CDB0Val;
            CDB0_exec_stat.Target = 0;
            CDB0_exec_stat.Cause = 0;

            if(CDB0_bank_sel == 0) {
                rob_exec_stat[0].CDB0(CDB0_addr, CDB0_exec_stat);
                rob_busy0[CDB0_addr] := 0;
            } else if(CDB0_bank_sel == 1) {
                rob_exec_stat[1].CDB0(CDB0_addr, CDB0_exec_stat);
                rob_busy1[CDB0_addr] := 0;
            }
        }
    }
    func CDB1 {
        wire CDB1_bank_sel;
        wire CDB1_addr[LOG2_ROB_NUM_OF_ENTRIES];
        reorder_buffer_exec_t wire CDB1_exec_stat;

        if(!flush) {
            CDB1_bank_sel = CDB1Id[0];
            CDB1_addr = CDB1Id[ROB_TAG_SIZE-1:1];
            CDB1_exec_stat.Value = CDB1Val;
            CDB1_exec_stat.Target = 0;
            CDB1_exec_stat.Cause = 0;

            if(CDB1_bank_sel == 0) {
                rob_exec_stat[0].CDB1(CDB1_addr, CDB1_exec_stat);
                rob_busy0[CDB1_addr] := 0;
            } else if(CDB1_bank_sel == 1) {
                rob_exec_stat[1].CDB1(CDB1_addr, CDB1_exec_stat);
                rob_busy1[CDB1_addr] := 0;
            }
        }
    }
    func CDB2 {
        wire CDB2_bank_sel;
        wire CDB2_addr[LOG2_ROB_NUM_OF_ENTRIES];
        reorder_buffer_exec_t wire CDB2_exec_stat;

        if(!flush) {
            CDB2_bank_sel = CDB2Id[0];
            CDB2_addr = CDB2Id[ROB_TAG_SIZE-1:1];
            CDB2_exec_stat.Value = CDB2Val;
            CDB2_exec_stat.Target = CDB2Target;
            CDB2_exec_stat.Cause = SET_EXCEPTION(INSTRUCTION_ADDRESS_MISALIGNED, CDB2InstructionAddressMisaligned);

            if(CDB2_bank_sel == 0) {
                rob_exec_stat[0].CDB2(CDB2_addr, CDB2_exec_stat);
                rob_busy0[CDB2_addr] := 0;
            } else if(CDB2_bank_sel == 1) {
                rob_exec_stat[1].CDB2(CDB2_addr, CDB2_exec_stat);
                rob_busy1[CDB2_addr] := 0;
            }
        }
    }
    func CDB3 {
        wire CDB3_bank_sel;
        wire CDB3_addr[LOG2_ROB_NUM_OF_ENTRIES];
        reorder_buffer_exec_t wire CDB3_exec_stat;

        if(!flush) {
            CDB3_bank_sel = CDB3Id[0];
            CDB3_addr = CDB3Id[ROB_TAG_SIZE-1:1];
            CDB3_exec_stat.Value = CDB3Val;
            CDB3_exec_stat.Target = 0;
            CDB3_exec_stat.Cause = 0;

            if(CDB3_bank_sel == 0) {
                rob_exec_stat[0].CDB3(CDB3_addr, CDB3_exec_stat);
                rob_busy0[CDB3_addr] := 0;
            } else if(CDB3_bank_sel == 1) {
                rob_exec_stat[1].CDB3(CDB3_addr, CDB3_exec_stat);
                rob_busy1[CDB3_addr] := 0;
            }
        }
    }
    {
        reorder_buffer_exec_t wire commit_rob_exec_stat0;
        reorder_buffer_exec_t wire commit_rob_exec_stat1;
        reorder_buffer_t wire commit_rob;
        wire commit_valid0;
        wire commit_valid1;
        wire commit_busy0;
        wire commit_busy1;
        uop_t wire commit_uop0;
        uop_t wire commit_uop1;
        wire commit_cause0[16];
        wire commit_cause1[16];
        
        commit_valid0 = rob_valid0[head_idx];
        commit_valid1 = rob_valid1[head_idx];
        commit_busy0 = rob_busy0[head_idx];
        commit_busy1 = rob_busy1[head_idx];
        commit_rob = rob[head_idx]; 
        commit_rob_exec_stat0 = rob_exec_stat[0].commit(head_idx);
        commit_rob_exec_stat1 = rob_exec_stat[1].commit(head_idx);
        commit_uop0 = commit_rob.uOp0;
        commit_uop1 = commit_rob.uOp1;
        commit_cause0 = commit_rob_exec_stat0.Cause | commit_uop0.cause;
        commit_cause1 = commit_rob_exec_stat1.Cause | commit_uop1.cause;
        if(!commit_stall && (commit_valid0 | commit_valid1) && (!commit_busy0 && !commit_busy1)) {
            commit(head<<1,
                commit_valid0, commit_rob_exec_stat0.Value, commit_rob.uOp0, commit_rob.PC0,
                commit_rob_exec_stat0.Target, commit_rob.Inst0, commit_cause0, commit_rob.CSR_Value0,
                commit_valid1, commit_rob_exec_stat1.Value, commit_rob.uOp1, commit_rob.PC1,
                commit_rob_exec_stat1.Target, commit_rob.Inst1, commit_cause1, commit_rob.CSR_Value1
            );
            if(!flush) {
                head := next_head;
                rob_valid0[head_idx] := 0;
                rob_valid1[head_idx] := 0;
                rob_busy0[head_idx] := 0;
                rob_busy1[head_idx] := 0;
            }
        }
    }
    if(!flush) {
        if((tail[LOG2_ROB_NUM_OF_ENTRIES-1:0] == head[LOG2_ROB_NUM_OF_ENTRIES-1:0])
            && (tail[LOG2_ROB_NUM_OF_ENTRIES] != head[LOG2_ROB_NUM_OF_ENTRIES])) {
            full();
        }
    }
}

// commit
// uop.cause | Cause
