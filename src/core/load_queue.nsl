#include "load_queue.h"

module load_queue {
    load_queue_t reg ldq0 = 0;
    load_queue_t reg ldq1 = 0;
    load_queue_t reg ldq2 = 0;
    load_queue_t reg ldq3 = 0;
    reg tail[LOG2_LDQ_NUM_OF_ENTRIES+1] = 0;
    reg head[LOG2_LDQ_NUM_OF_ENTRIES+1] = 0;
    wire next_tail[LOG2_LDQ_NUM_OF_ENTRIES+1];
    wire next_head[LOG2_LDQ_NUM_OF_ENTRIES+1];

    next_tail = tail + 1;
    next_head = head + 1;
    func push {
        load_queue_t wire new_entry;

        if(!flush) {
            new_entry.Valid = 1;
            new_entry.A = push_A;
            new_entry.Op = push_Op;
            new_entry.RobId = push_RobId;

            any {
                tail[LOG2_LDQ_NUM_OF_ENTRIES-1:0] == 0: {ldq0 := new_entry;}
                tail[LOG2_LDQ_NUM_OF_ENTRIES-1:0] == 1: {ldq1 := new_entry;}
                tail[LOG2_LDQ_NUM_OF_ENTRIES-1:0] == 2: {ldq2 := new_entry;}
                tail[LOG2_LDQ_NUM_OF_ENTRIES-1:0] == 3: {ldq3 := new_entry;}
            }
            tail := next_tail;
        }
    }
    func pop {
        if(!flush) {
            any {
                head[LOG2_LDQ_NUM_OF_ENTRIES-1:0] == 0: return ldq0;
                head[LOG2_LDQ_NUM_OF_ENTRIES-1:0] == 1: return ldq1;
                head[LOG2_LDQ_NUM_OF_ENTRIES-1:0] == 2: return ldq2;
                head[LOG2_LDQ_NUM_OF_ENTRIES-1:0] == 3: return ldq3;
            }
            head := next_head;
        }
    }
    if(!flush) {
        if((tail[LOG2_LDQ_NUM_OF_ENTRIES-1:0] == head[LOG2_LDQ_NUM_OF_ENTRIES-1:0]) && (tail[LOG2_LDQ_NUM_OF_ENTRIES] != head[LOG2_LDQ_NUM_OF_ENTRIES])) {
            full();
        }
        if(tail == head) {
            empty();
        }
    }
    func flush {
        ldq0 := 0;
        ldq1 := 0;
        ldq2 := 0;
        ldq3 := 0;
        head := 0;
        tail := 0;
    }
}
