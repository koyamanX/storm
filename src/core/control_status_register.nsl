#include "control_status_register.h"
#include "csr.h"

module control_status_register {
    misa_t reg misa = 0;
    mvendorid_t reg mvendorid = 0;
    marchid_t reg marchid = 0;
    mimpid_t reg mimpid = 0;
    mhartid_t reg mhartid = 0;
    mstatush_t reg mstatush = 0;
    mstatus_t reg mstatus = 0;
    mtvec_t reg mtvec = {0, MTVEC_MODE_DIRECT};
    mip_t reg mip = 0;
    mie_t reg mie = 0;
    mscratch_t reg mscratch = 0;
    mepc_t reg mepc = 0;
    mtval_t reg mtval = 0;
    mcause_t reg mcause = 0;
    reg mode[2] = MACHINE;
    /*
        SXLEN=32
        UXLEN=32
    */
    wire ialign[2];

    ialign = if(misa.extensions & MISA_EXTENSIONS_C) 2'b01 else 2'b11;
    func reset {
        /* TODO: */
        mode                := MACHINE;
        misa.mxl            := MISA_MXL_XLEN32;
        misa.extensions     := (MISA_EXTENSIONS_I);
        mtvec.mode          := MTVEC_MODE_DIRECT;
        mtvec.base          := 0;
        mstatus.mie         := 0;
        mstatus.mprv        := 0;
        mstatus.mpp         := MACHINE;
        mstatush.mbe        := 0;   /* Little-endian */
    }
    func trap {
        mstatus_t wire trap_xstatus;
        mtvec_t wire trap_xtvec;
        mtval_t wire trap_xtval;

        any {
            (mode == MACHINE): {
                if(write && csr_wnum == MSTATUS) {
                    trap_xstatus = csr_wdata;
                } else {
                    trap_xstatus = mstatus;
                }
                if(write && csr_wnum == MTVEC) {
                    trap_xtvec = csr_wdata;
                } else {
                    trap_xtvec = mtvec;
                }
                if(write && csr_wnum == MTVAL) {
                    trap_xtval = csr_wdata;
                } else {
                    trap_xtval = mtvec;
                }
                mstatus.mpie    := trap_xstatus.mie;
                mstatus.mie     := 0;
                mstatus.mpp     := MACHINE;
                mode            := MACHINE;
                mcause          := trap_cause;
                mepc            := trap_pc;
                mtval           := trap_xtval;

                any {
                    (mtvec.mode == MTVEC_MODE_DIRECT): return {trap_xtvec.base, 2'b00} & ~ialign;
                    (mtvec.mode == MTVEC_MODE_VECTORED) && !trap_cause[31]: return {trap_xtvec.base, 2'b00} & ~ialign;
                    (mtvec.mode == MTVEC_MODE_VECTORED) && trap_cause[31]: return {trap_xtvec.base, 2'b00} + 32'({trap_cause[9:0], 2'b00}) & ~ialign;
                }
            }
        }
    }
    func mret {
        mstatus_t wire mret_mstatus;
        mepc_t wire mret_mepc;

        if(write && csr_wnum == MSTATUS) {
            mret_mstatus = csr_wdata;
        } else {
            mret_mstatus = mstatus;
        }
        if(write && csr_wnum == MEPC) {
            mret_mepc = csr_wdata;
        } else {
            mret_mepc = mepc;
        }

        mstatus.mie     := mret_mstatus.mpie;
        mstatus.mpie    := 1;
        mstatus.mpp     := MACHINE;
        mstatus.mprv    := 0;
        mode            := mret_mstatus.mpp;

        return mret_mepc & ~ialign;
    }
    func read {
        any {
            (mode >= MACHINE) && (csr_rnum == MISA): {
                return misa;
            }
            (mode >= MACHINE) && (csr_rnum == MVENDORID): {
                return mvendorid;
            }
            (mode >= MACHINE) && (csr_rnum == MARCHID): {
                return marchid;
            }
            (mode >= MACHINE) && (csr_rnum == MIMPID): {
                return mimpid;
            }
            (mode >= MACHINE) && (csr_rnum == MHARTID): {
                return mhartid;
            }
            (mode >= MACHINE) && (csr_rnum == MSTATUSH): {
                return mstatush;
            }
            (mode >= MACHINE) && (csr_rnum == MSTATUS): {
                return mstatus;
            }
            (mode >= MACHINE) && (csr_rnum == MTVEC): {
                return mtvec;
            }
            (mode >= MACHINE) && (csr_rnum == MIP): {
                return mip;
            }
            (mode >= MACHINE) && (csr_rnum == MIE): {
                return mie;
            }
            (mode >= MACHINE) && (csr_rnum == MSCRATCH): {
                return mscratch;
            }
            (mode >= MACHINE) && (csr_rnum == MEPC): {
                return mepc & ~ialign;
            }
            (mode >= MACHINE) && (csr_rnum == MCAUSE): {
                return mcause;
            }
            (mode >= MACHINE) && (csr_rnum == MTVAL): {
                return mtval;
            }
            else: {
                csr_read_illegal_instruction();
            }
        }
    }
    func write {
        mstatus_t wire xstatus;
        mtvec_t wire xtvec;
        mie_t wire xie;

        any {
            (mode >= MACHINE) && (csr_wnum == MISA): {
                // nop
            }
            (mode >= MACHINE) && (csr_wnum == MVENDORID): {
                // nop
            }
            (mode >= MACHINE) && (csr_wnum == MARCHID): {
                // nop
            }
            (mode >= MACHINE) && (csr_wnum == MIMPID): {
                // nop
            }
            (mode >= MACHINE) && (csr_wnum == MHARTID): {
                // nop
            }
            (mode >= MACHINE) && (csr_wnum == MSTATUSH): {
                /*
                    MBE is always 0
                    SBE is always 0
                */
            }
            (mode >= MACHINE) && (csr_wnum == MSTATUS): {
                xstatus = csr_wdata;
                /*
                    UBE is always 0
                    TVM is always 0
                    TW is always 0
                    TSR is always 0
                    SPIE is always 0
                    SIE is always 0
                    MPP takes MACHINE
                    SPP is always 0
                    MPRV is always 0
                    MXR is always 0
                    SUM is always 0
                    FS is always 0
                    XS is always 0
                    VS is always 0
                    SD is always 0
                */
                mstatus.mie     := xstatus.mie;
                mstatus.mpie    := xstatus.mpie;
                mstatus.mpp     := MACHINE;
            }
            (mode >= MACHINE) && (csr_wnum == MTVEC): {
                xtvec = csr_wdata;

                mtvec.base := xtvec.base;
                any {
                    xtvec.mode == MTVEC_MODE_DIRECT: mtvec.mode := xtvec.mode;
                    xtvec.mode == MTVEC_MODE_VECTORED: mtvec.mode := xtvec.mode;
                }
            }
            (mode >= MACHINE) && (csr_wnum == MIP): {
                /*
                    read-only and written through memory-mapped interrupt controller.
                    - MEIP
                    - MTIP
                    - MSIP

                    always 0
                    - SEIP
                    - STIP
                    - SSIP
                */
            }
            (mode >= MACHINE) && (csr_wnum == MIE): {
                xie = csr_wdata;
                mie.meie := xie.meie;
                mie.mtie := xie.mtie;
                mie.msie := xie.msie;
                /*
                    always 0
                    - SEIP
                    - STIP
                    - SSIP
                */
            }
            (mode >= MACHINE) && (csr_wnum == MSCRATCH): {
                mscratch := csr_wdata;
            }
            (mode >= MACHINE) && (csr_wnum == MEPC): {
                mepc := csr_wdata;
            }
            (mode >= MACHINE) && (csr_wnum == MCAUSE): {
                mcause := csr_wdata;
            }
            (mode >= MACHINE) && (csr_wnum == MTVAL): {
                mtval := csr_wdata;
            }
            else: {
                csr_write_illegal_instruction();
            }
        }
    }
}
