#include "control_status_register.h"
#include "csr.h"

module control_status_register {
	wire is_exist_csr_num[12];
	wire exist;
	func_self is_exist_csr(is_exist_csr_num): exist;
	wire is_readonly_csr_num[12];
	wire readonly;
	func_self is_readonly(is_readonly_csr_num): readonly;
    misa_t reg misa = 0;
    mvendorid_t reg mvendorid = 0;
    marchid_t reg marchid = 0;
    mimpid_t reg mimpid = 0;
    mhartid_t reg mhartid = 0;
    mstatush_t reg mstatush = 0;
    mstatus_t reg mstatus = 0;
    mtvec_t reg mtvec = {0, MTVEC_MODE_DIRECT};
    mip_t reg mip = 0;
    mie_t reg mie = 0;
    mscratch_t reg mscratch = 0;
    mepc_t reg mepc = 0;
    mtval_t reg mtval = 0;
    mcause_t reg mcause = 0;
    csr64_t reg mcycle = 0;
    func_self stop_mcycle();
    csr64_t reg minstret = 0;
    func_self stop_minstret();
    csr64_t reg mtime = 0;
    func_self stop_mtime();
    reg mode[2] = MACHINE;
    csr_write_buffer_t reg wbuf = 0;
    /*
        SXLEN=32
        UXLEN=32
    */

    ialign = IALIGN;
    meip = mip.meip;
    msip = software_interrupt_req_hart0;
    mtip = timer_interrupt_req_hart0;
    meie = mie.meie;
    msie = mie.msie;
    mtie = mie.mtie;
    mstatus_mie  = mstatus.mie;
    priv_mode = mode;
    func reset {
        /* TODO: */
        mode                := MACHINE;
        misa.mxl            := MISA_MXL_XLEN32;
        misa.extensions     := (MISA_EXTENSIONS_I);
        mtvec.mode          := MTVEC_MODE_DIRECT;
        mtvec.base          := 30'b10000_00000_00000_00000_00000_00000;
        mstatus.mie         := 0;
        mstatus.mprv        := 0;
        mstatus.mpp         := MACHINE;
        mstatush.mbe        := 0;   /* Little-endian */
        wbuf                := 0;
    }
	func flush {
		wbuf := 0;
	}
    func trap {
        mstatus_t wire trap_xstatus;
        mtvec_t wire trap_xtvec;

        wbuf := 0;
        any {
            (mode == MACHINE): {
                if(commit && wbuf.valid && wbuf.ptr == commit_ptr && wbuf.addr == MSTATUS) {
                    trap_xstatus = wbuf.data;
                } else {
                    trap_xstatus = mstatus;
                }
                if(commit && wbuf.valid && wbuf.ptr == commit_ptr && wbuf.addr == MTVEC) {
                    trap_xtvec = wbuf.data;
                } else {
                    trap_xtvec = mtvec;
                }
                mstatus.mpie    := trap_xstatus.mie;
                mstatus.mie     := 0;
                mstatus.mpp     := MACHINE;
                mode            := MACHINE;
                mcause          := trap_cause;
                mepc            := trap_pc;
                mtval           := trap_val;

                any {
                    (mtvec.mode == MTVEC_MODE_DIRECT): return {trap_xtvec.base, 2'b00} & ~IALIGN;
                    (mtvec.mode == MTVEC_MODE_VECTORED) && !trap_cause[31]: return {trap_xtvec.base, 2'b00} & ~IALIGN;
                    (mtvec.mode == MTVEC_MODE_VECTORED) && trap_cause[31]: return {trap_xtvec.base, 2'b00} + 32'({trap_cause[9:0], 2'b00}) & ~IALIGN;
                }
            }
        }
    }
    func mret {
        mstatus_t wire mret_mstatus;
        mepc_t wire mret_mepc;

        wbuf := 0;
        if(commit && wbuf.valid && wbuf.ptr == commit_ptr && wbuf.addr == MSTATUS) {
            mret_mstatus = wbuf.data;
        } else {
            mret_mstatus = mstatus;
        }
        if(commit && wbuf.valid && wbuf.ptr == commit_ptr && wbuf.addr == MEPC) {
            mret_mepc = wbuf.data;
        } else {
            mret_mepc = mepc;
        }

        mstatus.mie     := mret_mstatus.mpie;
        mstatus.mpie    := 1;
        mstatus.mpp     := MACHINE;
        mstatus.mprv    := 0;
        mode            := mret_mstatus.mpp;

        return mret_mepc & ~IALIGN;
    }
	func is_exist_csr {
		any {
            (mode >= MACHINE) && (is_exist_csr_num == MISA): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MVENDORID): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MARCHID): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MIMPID): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MHARTID): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MSTATUSH): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MSTATUS): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MTVEC): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MIP): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MIE): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MSCRATCH): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MEPC): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MCAUSE): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MTVAL): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MCYCLEH): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MCYCLE): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MINSTRETH): return 1;
            (mode >= MACHINE) && (is_exist_csr_num == MINSTRET): return 1;
            (mode >= USER) && (is_exist_csr_num == CYCLEH): return 1;
            (mode >= USER) && (is_exist_csr_num == CYCLE): return 1;
            (mode >= USER) && (is_exist_csr_num == INSTRETH): return 1;
            (mode >= USER) && (is_exist_csr_num == INSTRET): return 1;
            (mode >= USER) && (is_exist_csr_num == TIMEH): return 1;
            (mode >= USER) && (is_exist_csr_num == TIME): return 1;
			else: return 0;
        }
	}
	func is_readonly {
		if(is_readonly_csr_num[11:10] == 2'b11) {
			return 1;
		} else {
			return 0;
		}
	}
	func decode {
		is_readonly(decode_csr_num);
		is_exist_csr(decode_csr_num);
		any {
			decode_csr_rw == DECODE_CSR_RW && (readonly || exist): return 1;
			decode_csr_rw == DECODE_CSR_WO && (readonly || !exist): return 1;
			decode_csr_rw == DECODE_CSR_RO && !exist: return 1;
			else: return 0;
		}
	}
    func read {
        any {
            (mode >= MACHINE) && (csr_rnum == MISA): {
                return misa;
            }
            (mode >= MACHINE) && (csr_rnum == MVENDORID): {
                return mvendorid;
            }
            (mode >= MACHINE) && (csr_rnum == MARCHID): {
                return marchid;
            }
            (mode >= MACHINE) && (csr_rnum == MIMPID): {
                return mimpid;
            }
            (mode >= MACHINE) && (csr_rnum == MHARTID): {
                return mhartid;
            }
            (mode >= MACHINE) && (csr_rnum == MSTATUSH): {
                return mstatush;
            }
            (mode >= MACHINE) && (csr_rnum == MSTATUS): {
                return mstatus;
            }
            (mode >= MACHINE) && (csr_rnum == MTVEC): {
                return mtvec;
            }
            (mode >= MACHINE) && (csr_rnum == MIP): {
                return mip | (timer_interrupt_req_hart0 << 7) | (software_interrupt_req_hart0 << 3);
            }
            (mode >= MACHINE) && (csr_rnum == MIE): {
                return mie;
            }
            (mode >= MACHINE) && (csr_rnum == MSCRATCH): {
                return mscratch;
            }
            (mode >= MACHINE) && (csr_rnum == MEPC): {
                return mepc & ~IALIGN;
            }
            (mode >= MACHINE) && (csr_rnum == MCAUSE): {
                return mcause;
            }
            (mode >= MACHINE) && (csr_rnum == MTVAL): {
                return mtval;
            }
            (mode >= MACHINE) && (csr_rnum == MCYCLEH): {
                return mcycle.hi;
            }
            (mode >= MACHINE) && (csr_rnum == MCYCLE): {
                return mcycle.lo;
            }
            (mode >= MACHINE) && (csr_rnum == MINSTRETH): {
                return minstret.hi;
            }
            (mode >= MACHINE) && (csr_rnum == MINSTRET): {
                return minstret.lo;
            }
            (mode >= USER) && (csr_rnum == CYCLEH): {
                return mcycle.hi;
            }
            (mode >= USER) && (csr_rnum == CYCLE): {
                return mcycle.lo;
            }
            (mode >= USER) && (csr_rnum == INSTRETH): {
                return minstret.hi;
            }
            (mode >= USER) && (csr_rnum == INSTRET): {
                return minstret.lo;
            }
            (mode >= USER) && (csr_rnum == TIMEH): {
                return mtime.hi;
            }
            (mode >= USER) && (csr_rnum == TIME): {
                return mtime.lo;
            }
        }
    }
    func write {
        wire wbuf_age[REORDER_BUFFER_PTR_SIZE+1];
        wire write_age[REORDER_BUFFER_PTR_SIZE+1];

        wbuf_age = PTR2AGE(wbuf.ptr, rob_head_ptr);
        write_age = PTR2AGE(write_ptr, rob_head_ptr);
        if(~wbuf.valid) {
            wbuf.valid := 1;
            wbuf.addr := write_addr;
            wbuf.data := write_data;
            wbuf.ptr := write_ptr;
        } else if(wbuf.valid && wbuf_age > write_age) {
            wbuf.valid := 1;
            wbuf.addr := write_addr;
            wbuf.data := write_data;
            wbuf.ptr := write_ptr;
        }
        any {
                (mode >= MACHINE) && (write_addr == MISA): ;
                (mode >= MACHINE) && (write_addr == MVENDORID): ;
                (mode >= MACHINE) && (write_addr == MARCHID): ;
                (mode >= MACHINE) && (write_addr == MIMPID): ;
                (mode >= MACHINE) && (write_addr == MHARTID): ;
                (mode >= MACHINE) && (write_addr == MSTATUSH): ;
                (mode >= MACHINE) && (write_addr == MSTATUS): ;
                (mode >= MACHINE) && (write_addr == MTVEC): ;
                (mode >= MACHINE) && (write_addr == MIP): ;
                (mode >= MACHINE) && (write_addr == MIE): ;
                (mode >= MACHINE) && (write_addr == MSCRATCH): ;
                (mode >= MACHINE) && (write_addr == MEPC): ;
                (mode >= MACHINE) && (write_addr == MCAUSE): ;
                (mode >= MACHINE) && (write_addr == MTVAL): ;
                (mode >= MACHINE) && (write_addr == MCYCLEH): ;
                (mode >= MACHINE) && (write_addr == MCYCLE): ;
                (mode >= MACHINE) && (write_addr == MINSTRETH): ;
                (mode >= MACHINE) && (write_addr == MINSTRET): ;
        }
    }
    func commit {
        mstatus_t wire xstatus;
        mtvec_t wire xtvec;
        mie_t wire xie;

        if(wbuf.valid && wbuf.ptr == commit_ptr) {
            wbuf.valid := 0;
            any {
                (mode >= MACHINE) && (wbuf.addr == MISA): {
                    // nop
                }
                (mode >= MACHINE) && (wbuf.addr == MVENDORID): {
                    // nop
                }
                (mode >= MACHINE) && (wbuf.addr == MARCHID): {
                    // nop
                }
                (mode >= MACHINE) && (wbuf.addr == MIMPID): {
                    // nop
                }
                (mode >= MACHINE) && (wbuf.addr == MHARTID): {
                    // nop
                }
                (mode >= MACHINE) && (wbuf.addr == MSTATUSH): {
                    /*
                        MBE is always 0
                        SBE is always 0
                    */
                }
                (mode >= MACHINE) && (wbuf.addr == MSTATUS): {
                    xstatus = wbuf.data;
                    /*
                        UBE is always 0
                        TVM is always 0
                        TW is always 0
                        TSR is always 0
                        SPIE is always 0
                        SIE is always 0
                        MPP takes MACHINE
                        SPP is always 0
                        MPRV is always 0
                        MXR is always 0
                        SUM is always 0
                        FS is always 0
                        XS is always 0
                        VS is always 0
                        SD is always 0
                    */
                    mstatus.mie     := xstatus.mie;
                    mstatus.mpie    := xstatus.mpie;
                    mstatus.mpp     := MACHINE;
                }
                (mode >= MACHINE) && (wbuf.addr == MTVEC): {
                    xtvec = wbuf.data;

                    mtvec.base := xtvec.base;
                    any {
                        xtvec.mode == MTVEC_MODE_DIRECT: mtvec.mode := xtvec.mode;
                        xtvec.mode == MTVEC_MODE_VECTORED: mtvec.mode := xtvec.mode;
                    }
                }
                (mode >= MACHINE) && (wbuf.addr == MIP): {
                    /*
                        read-only and written through memory-mapped interrupt controller.
                        - MEIP
                        - MTIP
                        - MSIP

                        always 0
                        - SEIP
                        - STIP
                        - SSIP
                    */
                }
                (mode >= MACHINE) && (wbuf.addr == MIE): {
                    xie = wbuf.data;
                    mie.meie := xie.meie;
                    mie.mtie := xie.mtie;
                    mie.msie := xie.msie;
                    /*
                        always 0
                        - SEIP
                        - STIP
                        - SSIP
                    */
                }
                (mode >= MACHINE) && (wbuf.addr == MSCRATCH): {
                    mscratch := wbuf.data;
                }
                (mode >= MACHINE) && (wbuf.addr == MEPC): {
                    mepc := wbuf.data;
                }
                (mode >= MACHINE) && (wbuf.addr == MCAUSE): {
                    mcause := wbuf.data;
                }
                (mode >= MACHINE) && (wbuf.addr == MTVAL): {
                    mtval := wbuf.data;
                }
                (mode >= MACHINE) && (wbuf.addr == MCYCLEH): {
                    mcycle.hi := wbuf.data;
                    stop_mcycle();
                }
                (mode >= MACHINE) && (wbuf.addr == MCYCLE): {
                    mcycle.lo := wbuf.data;
                    stop_mcycle();
                }
                (mode >= MACHINE) && (wbuf.addr == MINSTRETH): {
                    minstret.hi := wbuf.data;
                    stop_minstret();
                }
                (mode >= MACHINE) && (wbuf.addr == MINSTRET): {
                    minstret.lo := wbuf.data;
                    stop_minstret();
                }
            }
        }
    }
    func update_instret {
        if(!stop_minstret) {
            minstret := minstret + 2;
        }
    }
    if(!stop_mcycle) {
        mcycle++;
    }
    mtime++;
}
