#include "control_status_register.h"
#include "csr.h"

module control_status_register {
    misa_t reg misa = 0;
    mvendorid_t reg mvendorid = 0;
    marchid_t reg marchid = 0;
    mimpid_t reg mimpid = 0;
    mhartid_t reg mhartid = 0;
    mstatush_t reg mstatush = 0;
    mstatus_t reg mstatus = 0;
    mtvec_t reg mtvec = {0, MTVEC_MODE_DIRECT};
    mip_t reg mip = 0;
    mie_t reg mie = 0;
    mscratch_t reg mscratch = 0;
    mepc_t reg mepc = 0;
    mtval_t reg mtval = 0;
    mcause_t reg mcause = 0;
    reg mode = MACHINE;
    /*
        SXLEN=32
        UXLEN=32
    */
    wire ialign[2];

    ialign = if(misa.extensions & MISA_EXTENSIONS_C) 2'b00 else 2'b11;
    func reset {
        /* TODO: */
        mode                := MACHINE;
        misa.mxl            := MISA_MXL_XLEN32;
        misa.extensions     := (MISA_EXTENSIONS_I);
        mtvec.mode          := MTVEC_MODE_DIRECT;
        mtvec.base          := 0;
        mstatus.mie         := 0;
        mstatus.mprv        := 0;
        mstatus.mpp         := MACHINE;
        mstatush.mbe        := 0;   /* Little-endian */
    }
    func trap {
        any {
            (mode == MACHINE): {
                mstatus.mpie    := mstatus.mie;
                mstatus.mie     := 0;
                mstatus.mpp     := trap_mode;
                mode            := trap_mode;
                mcause          := trap_cause;
                mepc            := trap_pc;
                mtval           := mtval;

                any {
                    (mtvec.mode == MTVEC_MODE_DIRECT): return {mtvec.base, 2'b00} & ~ialign;
                    (mtvec.mode == MTVEC_MODE_VECTORED) && !trap_cause[31]: return {mtvec.base, 2'b00} & ~ialign;
                    (mtvec.mode == MTVEC_MODE_VECTORED) && trap_cause[31]: return {mtvec.base, 2'b00} + 32'({trap_cause[9:0], 2'b00}) & ~ialign;
                }
            }
        }
    }
    func mret {
        mstatus.mie     := mstatus.mpie;
        mstatus.mpie    := 1;
        mstatus.mpp     := MACHINE;
        mstatus.mprv    := 0;
        mode            := mstatus.mpp;

        return mepc & ~ialign;
    }
    func read {
        if(!trap) {
            any {
                (mode >= MACHINE) && (csr_rnum == MISA): {
                    return misa;
                }
                (mode >= MACHINE) && (csr_rnum == MVENDORID): {
                    return mvendorid;
                }
                (mode >= MACHINE) && (csr_rnum == MARCHID): {
                    return marchid;
                }
                (mode >= MACHINE) && (csr_rnum == MIMPID): {
                    return mimpid;
                }
                (mode >= MACHINE) && (csr_rnum == MHARTID): {
                    return mhartid;
                }
                (mode >= MACHINE) && (csr_rnum == MSTATUSH): {
                    return mstatush;
                }
                (mode >= MACHINE) && (csr_rnum == MSTATUS): {
                    return mstatus;
                }
                (mode >= MACHINE) && (csr_rnum == MTVEC): {
                    return mtvec;
                }
                (mode >= MACHINE) && (csr_rnum == MIP): {
                    return mip;
                }
                (mode >= MACHINE) && (csr_rnum == MIE): {
                    return mie;
                }
                (mode >= MACHINE) && (csr_rnum == MSCRATCH): {
                    return mscratch;
                }
                (mode >= MACHINE) && (csr_rnum == MEPC): {
                    return mepc & ~ialign;
                }
                (mode >= MACHINE) && (csr_rnum == MCAUSE): {
                    return mcause;
                }
                (mode >= MACHINE) && (csr_rnum == MTVAL): {
                    return mtval;
                }
                else: {
                    csr_illegal_instruction();
                }
            }
        }
    }
    func write {
        mstatus_t wire xstatus;
        mtvec_t wire xtvec;
        mie_t wire xie;

        if(!trap) {
            any {
                (mode >= MACHINE) && (csr_wnum == MISA): {
                    // nop
                }
                (mode >= MACHINE) && (csr_wnum == MVENDORID): {
                    // nop
                }
                (mode >= MACHINE) && (csr_wnum == MARCHID): {
                    // nop
                }
                (mode >= MACHINE) && (csr_wnum == MIMPID): {
                    // nop
                }
                (mode >= MACHINE) && (csr_wnum == MHARTID): {
                    // nop
                }
                (mode >= MACHINE) && (csr_wnum == MSTATUSH): {
                    /*
                        MBE is always 0
                        SBE is always 0
                    */
                }
                (mode >= MACHINE) && (csr_wnum == MSTATUS): {
                    xstatus = csr_wdata;
                    /*
                        UBE is always 0
                        TVM is always 0
                        TW is always 0
                        TSR is always 0
                        SPIE is always 0
                        SIE is always 0
                        MPP takes MACHINE
                        SPP is always 0
                        MPRV is always 0
                        MXR is always 0
                        SUM is always 0
                        FS is always 0
                        XS is always 0
                        VS is always 0
                        SD is always 0
                    */
                    mstatus.mie     := xstatus.mie;
                    mstatus.mpie    := xstatus.mpie;
                    mstatus.mpp     := MACHINE;
                }
                (mode >= MACHINE) && (csr_wnum == MTVEC): {
                    xtvec = csr_wdata;

                    mtvec.base := xtvec.base;
                    any {
                        xtvec.mode == MTVEC_MODE_DIRECT: mtvec.mode := xtvec.mode;
                        xtvec.mode == MTVEC_MODE_VECTORED: mtvec.mode := xtvec.mode;
                    }
                }
                (mode >= MACHINE) && (csr_wnum == MIP): {
                    /*
                        read-only and written through memory-mapped interrupt controller.
                        - MEIP
                        - MTIP
                        - MSIP

                        always 0
                        - SEIP
                        - STIP
                        - SSIP
                    */
                }
                (mode >= MACHINE) && (csr_wnum == MIE): {
                    xie = csr_wdata;
                    mie.meie := xie.meie;
                    mie.mtie := xie.mtie;
                    mie.msie := xie.msie;
                    /*
                        always 0
                        - SEIP
                        - STIP
                        - SSIP
                    */
                }
                (mode >= MACHINE) && (csr_wnum == MSCRATCH): {
                    mscratch := csr_wdata;
                }
                (mode >= MACHINE) && (csr_wnum == MEPC): {
                    mepc := csr_wdata;
                }
                (mode >= MACHINE) && (csr_wnum == MCAUSE): {
                    mcause := csr_wdata;
                }
                (mode >= MACHINE) && (csr_wnum == MTVAL): {
                    mtval := csr_wdata;
                }
                else: {
                    csr_illegal_instruction();
                }
            }
        }
    }
}
