#include "turboV.h"
#include "ifetch_unit.h"
#include "alu32.h"
#include "wishbone_common.h"
#include "uop_decoder.h"
#include "register_file.h"
#include "opcode_map.h"
#include "load_store_unit.h"
#include "control_status_register.h"
#include "priv.h"
#include "uops.h"
#include "reorder_buffer.h"
#include "free_list.h"
#include "issue_queue.h"

#ifdef ENABLE_DEBUG
#define DEBUG_COMMIT0(pc, inst, cause) debug_commit0(pc, inst, cause)
#define DEBUG_COMMIT1(pc, inst, cause) debug_commit1(pc, inst, cause)
#else
#define DEBUG_COMMIT0(pc, inst, cause)
#define DEBUG_COMMIT1(pc, inst, cause)
#endif

struct issue_packet_t {
	pc[XLEN];
	pred0;
	pred1;
	valid0;
	valid1;
};

// TODO:
#define READY 1'b0
#define BUSY 1'b1

module turboV {
    proc_name warm_reset();
    /* Decode stage */
    proc_name decode();
	issue_packet_t reg issue_packet;
	decoder_packet_t reg decoder_packet0;
	decoder_packet_t reg decoder_packet1;
	proc_name issue(issue_packet, decoder_packet0, decoder_packet1);
	proc_name register_read();
	proc_name execute_alu0();
	proc_name execute_alu1();
	proc_name execute_lsu0();
	proc_name writeback_alu0();
	proc_name writeback_alu1();
	proc_name writeback_lsu0();
	/* Pipeline flush */
    func_self flush();
    /* Instruction Fetch Unit */
    ifetch_unit ifu;
    /* Instruction decoder */
    uop_decoder udec0;
    uop_decoder udec1;
    /* General Purpose Register */
    register_file gpr;
    /* Load Store Unit */
    load_store_unit lsu;
    /* CSR */
    control_status_register csr;
    /* variable for generate statement */
    integer i_;
	reorder_buffer rob;
	free_list freelist;
	mem register_map_table[32][6];
	mem register_status_table[32][1] = {0};
	issue_queue iq_alu0;
	issue_queue iq_alu1;
	alu32 alu0;
	alu32 alu1;

    func reset {
        if(!warm_reset) {
            warm_reset.invoke();
        }
    }
    proc warm_reset seq {
        {
            /* Cycle 1: Reset */
            ifu.reset();
            csr.reset();
			freelist.reset();
			generate(i_ = 0; i_ < 32; i_++) {
				register_map_table[i_] := i_;
				register_status_table[i_] := READY;
			}
        }
        {
            /* Cycle 2: Start inst fetch */
            ifu.redirect(csr.trap(0, 0, 0));
            decode();
            finish();
        }
    }
    func flush {
        /* Flush all stage */
        decode.finish();
        issue.finish();
        execute_alu0.finish();
        execute_lsu0.finish();
        writeback_alu0.finish();
        writeback_lsu0.finish();
        /* Flush ROB, RSs and LSQs */
        lsu.flush();
		/* Start decode */
        decode.invoke();
    }
    proc decode {
		state_name decode0, decode1;
		fetch_packet_t wire decode_fetch_packet;

		state decode0 {
			if(!ifu.ibuf_empty) {
				decode_fetch_packet = ifu.ibuf_pop();
				udec0.decode({decode_fetch_packet.pc, 3'b000}, decode_fetch_packet.inst0);
				udec1.decode({decode_fetch_packet.pc, 3'b100}, decode_fetch_packet.inst1);

				if(decode_fetch_packet.valid0 && decode_fetch_packet.valid1) {
					/* Check if structural hazard occurs, if so, issue first insts
					   and second one goes to decode1 stage.
					any {
						else: {
							// both insts can be issued.
						}
					}
					*/
					// TODO:
					issue.invoke({decode_fetch_packet.pc,
							decode_fetch_packet.pred0, decode_fetch_packet.pred1,
							decode_fetch_packet.valid0, decode_fetch_packet.valid1},
							udec0.packet, udec1.packet);

				} else {
					// Either way0 or way1 is valid.
					// Both invalid is not enter here, ifetch_unit never pushes such case.
					// TODO:
					issue.invoke({decode_fetch_packet.pc,
							decode_fetch_packet.pred0, decode_fetch_packet.pred1,
							decode_fetch_packet.valid0, decode_fetch_packet.valid1},
							udec0.packet, udec1.packet);
				}
			}
		}
		state decode1 {
			goto decode0;
		}
    }
    proc issue {
		reorder_buffer_t wire issue_reorder_buffer_entry;
		wire issue_PC[29];
		// issue slot 0
		wire issue_inst0_valid;
		wire issue_inst0_ptr[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES];
		wire issue_inst0_lrd[5];
		wire issue_inst0_prd[6];
		wire issue_inst0_pprd[6];
		wire issue_inst0_rs1_valid;
		wire issue_inst0_rs1_ready;
		wire issue_inst0_rs1_sel[SIZEOF_REG_SEL];
		wire issue_inst0_lrs1[5];
		wire issue_inst0_prs1[6];
		wire issue_inst0_rs2_valid;
		wire issue_inst0_rs2_ready;
		wire issue_inst0_rs2_sel[SIZEOF_REG_SEL];
		wire issue_inst0_lrs2[5];
		wire issue_inst0_prs2[6];
		wire issue_inst0_cause[SIZEOF_CAUSE_T];
		uop_t wire issue_inst0_uop;
		wire issue_inst0_imm[32];
		// issue slot 1
		wire issue_inst1_valid;
		wire issue_inst1_ptr[LOG2_REORDER_BUFFER_NUM_OF_ENTRIES];
		wire issue_inst1_lrd[5];
		wire issue_inst1_prd[6];
		wire issue_inst1_pprd[6];
		wire issue_inst1_rs1_valid;
		wire issue_inst1_rs1_ready;
		wire issue_inst1_rs1_sel[SIZEOF_REG_SEL];
		func_self issue_inst1_rs1_ready_bypass;
		wire issue_inst1_lrs1[5];
		wire issue_inst1_prs1[6];
		wire issue_inst1_rs2_valid;
		wire issue_inst1_rs2_ready;
		wire issue_inst1_rs2_sel[SIZEOF_REG_SEL];
		func_self issue_inst1_rs2_ready_bypass;
		wire issue_inst1_lrs2[5];
		wire issue_inst1_prs2[6];
		wire issue_inst1_cause[SIZEOF_CAUSE_T];
		uop_t wire issue_inst1_uop;
		wire issue_inst1_imm[32];

		issue_inst0_uop = decoder_packet0.uop;
		issue_inst1_uop = decoder_packet1.uop;
		if((freelist.count >= 2) && (!rob.full)) {
			issue_PC = issue_packet.pc[31:3];
			// inst0
			issue_inst0_valid = issue_packet.valid0;
			issue_inst0_cause = |decoder_packet0.cause;
			issue_inst0_lrd = decoder_packet0.lrd;
			issue_inst0_rs1_sel = issue_inst0_uop.rs1_sel;
			issue_inst0_lrs1 = decoder_packet0.lrs1;
			issue_inst0_rs2_sel = issue_inst0_uop.rs2_sel;
			issue_inst0_lrs2 = decoder_packet0.lrs2;
			issue_inst0_imm = decoder_packet0.imm;
			// inst1
			issue_inst1_valid = issue_packet.valid1;
			issue_inst1_cause = |decoder_packet1.cause;
			issue_inst1_lrd = decoder_packet1.lrd;
			issue_inst1_rs1_sel = issue_inst1_uop.rs1_sel;
			issue_inst1_lrs1 = decoder_packet1.lrs1;
			issue_inst1_rs2_sel = issue_inst1_uop.rs2_sel;
			issue_inst1_lrs2 = decoder_packet1.lrs2;
			issue_inst1_imm = decoder_packet1.imm;

			// Rename destination registers
			issue_inst0_pprd = register_map_table[issue_inst0_lrd];
			issue_inst1_pprd = register_map_table[issue_inst1_lrd];
			if(issue_packet.valid0 && (issue_inst0_lrd != 0)) {
				issue_inst0_prd = freelist.pop0();
				if(!(issue_packet.valid1 && (issue_inst0_lrd != 0)
							&& (issue_inst0_lrd == issue_inst1_lrd))) {
					register_map_table[issue_inst0_lrd] := issue_inst0_prd;
					register_status_table[issue_inst0_lrd] := BUSY;
				}
			}
			if(issue_packet.valid1 && (issue_inst1_lrd != 0)) {
				issue_inst1_prd = freelist.pop1();
				register_map_table[issue_inst1_lrd] := issue_inst1_prd;
				register_status_table[issue_inst1_lrd] := BUSY;
			}
			// Rename source registers
			if(issue_packet.valid0) {
				issue_inst0_prs1 = register_map_table[issue_inst0_lrs1];
				issue_inst0_prs2 = register_map_table[issue_inst0_lrs2];
			}
			if(issue_packet.valid0 && issue_packet.valid1
					&& issue_inst0_lrd == issue_inst1_lrs1) {
				issue_inst1_prs1 = issue_inst0_prs1;
				issue_inst1_rs1_ready_bypass();
			} else {
				issue_inst1_prs1 = register_map_table[issue_inst1_lrs1];
			}
			if(issue_packet.valid0 && issue_packet.valid1
					&& issue_inst0_lrd == issue_inst1_lrs2) {
				issue_inst1_prs2 = issue_inst0_prs2;
				issue_inst1_rs2_ready_bypass();
			} else {
				issue_inst1_prs2 = register_map_table[issue_inst1_lrs2];
			}
			issue_inst0_rs1_valid = issue_packet.valid0
				&& (issue_inst0_rs1_sel == RS1_SEL_REG);
			issue_inst0_rs2_valid = issue_packet.valid0
				&& (issue_inst0_rs2_sel == RS1_SEL_REG);
			issue_inst1_rs1_valid = issue_packet.valid1
				&& (issue_inst1_rs1_sel == RS1_SEL_REG);
			issue_inst1_rs2_valid = issue_packet.valid1
				&& (issue_inst1_rs2_sel == RS1_SEL_REG);
			// Source register ready
			issue_inst0_rs1_ready = issue_packet.valid0
				&& register_status_table[issue_inst1_lrs1];
			issue_inst0_rs2_ready = issue_packet.valid0
				&& register_status_table[issue_inst1_lrs2];
			issue_inst1_rs1_ready = if(issue_inst1_rs1_ready_bypass) issue_inst0_rs1_ready
				else issue_packet.valid1 && register_status_table[issue_inst1_lrs1];
			issue_inst1_rs2_ready = if(issue_inst1_rs2_ready_bypass) issue_inst0_rs2_ready
				else issue_packet.valid1 && register_status_table[issue_inst1_lrs2];

			rob.issue(issue_PC,
					issue_inst0_valid, issue_inst0_uop, issue_inst0_lrd, issue_inst0_pprd, issue_inst0_cause,
					issue_inst1_valid, issue_inst1_uop, issue_inst1_lrd, issue_inst1_pprd, issue_inst1_cause);
			// TODO: NSL does not support mod.sig_o[_int(N)]
			issue_inst0_ptr = {rob.ptr, 1'b0};
			issue_inst1_ptr = {rob.ptr, 1'b1};
			// TODO:
			iq_alu0.issue(issue_inst0_ptr, issue_inst0_uop, issue_inst0_prd,
					issue_inst0_rs1_valid, issue_inst0_rs1_ready, issue_inst0_prs1,
					issue_inst0_rs2_valid, issue_inst0_rs2_ready, issue_inst0_prs2,
					issue_inst0_imm);
			iq_alu1.issue(issue_inst0_ptr, issue_inst1_uop, issue_inst1_prd,
					issue_inst1_rs1_valid, issue_inst1_rs1_ready, issue_inst1_prs1,
					issue_inst1_rs2_valid, issue_inst1_rs2_ready, issue_inst1_prs2,
					issue_inst1_imm);
			// TODO:
			finish();
		}
    }
    proc execute_alu0 {
    }
    proc execute_alu1 {
    }
    proc execute_lsu0 {
    }
    proc writeback_alu0 {
    }
    proc writeback_alu1 {
    }
    proc writeback_lsu0 {
    }
    /*
        Interrupts
    */
    func timer_interrupt_req_hart0 {
        csr.timer_interrupt_req_hart0();
    }
    func software_interrupt_req_hart0 {
        csr.software_interrupt_req_hart0();
    }

    /*
        Bus arbiter for instruction fetch unit and load store unit.
        LSU has higher priority.
    */
    {
        reg ifu_grant = 0;
        reg lsu_grant = 0;
        ifu.CLK_I = CLK_I;
        ifu.RST_I = RST_I;
        lsu.CLK_I = CLK_I;
        lsu.RST_I = RST_I;
        alt {
            lsu.CYC_O && !lsu_grant && !ifu_grant: {
                lsu_grant := 1;
                lsu.STALL_I();
                ifu.STALL_I();
            }
            ifu.CYC_O && !ifu_grant && !lsu_grant: {
                ifu_grant := 1;
                lsu.STALL_I();
                ifu.STALL_I();
            }
        }
        alt {
            lsu_grant && lsu.CYC_O && ACK_I: {
                lsu_grant := 0;
            }
            ifu_grant && ifu.CYC_O && ACK_I: {
                ifu_grant := 0;
            }
        }
        alt {
            lsu_grant: {
                ADR_O = lsu.ADR_O;
                SEL_O = lsu.SEL_O;
                DAT_O = lsu.DAT_O;
                if(lsu.CYC_O) CYC_O();
                if(lsu.STB_O) STB_O();
                if(lsu.WE_O) WE_O();
                if(lsu.LOCK_O) LOCK_O();
                lsu.DAT_I = DAT_I;
                if(ERR_I) lsu.ERR_I();
                if(RTY_I) lsu.RTY_I();
                if(STALL_I) lsu.STALL_I();
                if(ACK_I) lsu.ACK_I();
                ifu.STALL_I();
            }
            ifu_grant: {
                ADR_O = ifu.ADR_O;
                SEL_O = ifu.SEL_O;
                DAT_O = ifu.DAT_O;
                if(ifu.CYC_O) CYC_O();
                if(ifu.STB_O) STB_O();
                if(ifu.WE_O) WE_O();
                if(ifu.LOCK_O) LOCK_O();
                ifu.DAT_I = DAT_I;
                if(ERR_I) ifu.ERR_I();
                if(RTY_I) ifu.RTY_I();
                if(STALL_I) ifu.STALL_I();
                if(ACK_I) ifu.ACK_I();
                lsu.STALL_I();
            }
        }
    }
}
