#include "turboV.h"
#include "ifetch_unit.h"
#include "alu32.h"
#include "wishbone_common.h"
#include "uop_decoder.h"
#include "register_file.h"
#include "opcode_map.h"
#include "bru32.h"
#include "load_store_unit.h"
#include "control_status_register.h"
#include "priv.h"
#include "uops.h"
#include "active_list.h"
#include "free_list.h"

#ifdef ENABLE_DEBUG
#define DEBUG_COMMIT0(pc, inst, cause) debug_commit0(pc, inst, cause)
#define DEBUG_COMMIT1(pc, inst, cause) debug_commit1(pc, inst, cause)
#else
#define DEBUG_COMMIT0(pc, inst, cause)
#define DEBUG_COMMIT1(pc, inst, cause)
#endif

struct issue_packet_t {
	pc[XLEN];
	pred0;
	pred1;
	valid0;
	valid1;
};

// TODO:
#define READY 1'b0
#define BUSY 1'b1

module turboV {
    proc_name warm_reset();
    /* Decode stage */
    proc_name decode();
	issue_packet_t reg issue_packet;
	uop_t reg issue_uop0;
	uop_t reg issue_uop1;
	proc_name issue(issue_packet, issue_uop0, issue_uop1);
	proc_name register_read();
	proc_name execute_alu0();
	proc_name execute_bru0();
	proc_name execute_lsu0();
	proc_name writeback_alu0();
	proc_name writeback_bru0();
	proc_name writeback_lsu0();
	/* Pipeline flush */
    func_self flush();
    /* Instruction Fetch Unit */
    ifetch_unit ifu;
    /* Instruction decoder */
    uop_decoder udec0;
    uop_decoder udec1;
    /* General Purpose Register */
    register_file gpr;
    /* Load Store Unit */
    load_store_unit lsu;
    /* CSR */
    control_status_register csr;
    /* variable for generate statement */
    integer i_;
	active_list activelist;
	free_list freelist;
	mem register_map_table[32][6];
	mem register_status_table[32][1] = {0};

    func reset {
        if(!warm_reset) {
            warm_reset.invoke();
        }
    }
    proc warm_reset seq {
        {
            /* Cycle 1: Reset */
            ifu.reset();
            csr.reset();
			freelist.reset();
			generate(i_ = 0; i_ < 32; i_++) {
				register_map_table[i_] := i_;
				register_status_table[i_] := READY;
			}
        }
        {
            /* Cycle 2: Start inst fetch */
            ifu.redirect(csr.trap(0, 0, 0));
            decode();
            finish();
        }
    }
    func flush {
        /* Flush all stage */
        decode.finish();
        issue.finish();
        execute_alu0.finish();
        execute_bru0.finish();
        execute_lsu0.finish();
        writeback_alu0.finish();
        writeback_bru0.finish();
        writeback_lsu0.finish();
        /* Flush ROB, RSs and LSQs */
        lsu.flush();
		/* Start decode */
        decode.invoke();
    }
    proc decode {
		state_name decode0, decode1;
		fetch_packet_t wire decode_fetch_packet;

		state decode0 {
			if(!ifu.ibuf_empty) {
				decode_fetch_packet = ifu.ibuf_pop();
				udec0.decode(decode_fetch_packet.inst0);
				udec1.decode(decode_fetch_packet.inst1);

				if(decode_fetch_packet.valid0 && decode_fetch_packet.valid1) {
					/* Check if structural hazard occurs, if so, issue first insts
					   and second one goes to decode1 stage.
					any {
						else: {
							// both insts can be issued.
						}
					}
					*/
					// TODO:
					issue.invoke({decode_fetch_packet.pc,
							decode_fetch_packet.pred0, decode_fetch_packet.pred1,
							decode_fetch_packet.valid0, decode_fetch_packet.valid1},
							udec0.uop, udec1.uop);

				} else {
					// Either way0 or way1 is valid.
					// Both invalid is not enter here, ifetch_unit never pushes such case.
					// TODO:
					issue.invoke({decode_fetch_packet.pc,
							decode_fetch_packet.pred0, decode_fetch_packet.pred1,
							decode_fetch_packet.valid0, decode_fetch_packet.valid1},
							udec0.uop, udec1.uop);
				}
			}
		}
		state decode1 {
			goto decode0;
		}
    }
    proc issue {
		active_list_t wire issue_active_list_entry;

		if((freelist.count >= 2) && (!activelist.full)) {
			issue_active_list_entry.valid0 = issue_packet.valid0;
			issue_active_list_entry.valid1 = issue_packet.valid1;
			issue_active_list_entry.PC = issue_packet.pc[31:3];
			issue_active_list_entry.exception0 = |issue_uop0.cause;
			issue_active_list_entry.exception1 = |issue_uop1.cause;
			issue_active_list_entry.retired0 = !issue_packet.valid0;
			issue_active_list_entry.retired1 = !issue_packet.valid1;
			issue_active_list_entry.dreg0 = issue_uop0.lrd;
			issue_active_list_entry.dreg1 = issue_uop1.lrd;

			if(issue_packet.valid0 && (issue_uop0.lrd != 0)) {
				freelist.pop0();
				if(!(issue_packet.valid1 && (issue_uop1.lrd != 0)
							&& (issue_uop0.lrd == issue_uop1.lrd))) {
					register_map_table[issue_uop0.lrd] := freelist.pop0_data;
					register_status_table[issue_uop0.lrd] := BUSY;
				}
				issue_active_list_entry.ppreg0 = register_map_table[issue_uop0.lrd];
			}
			if(issue_packet.valid1 && (issue_uop1.lrd != 0)) {
				freelist.pop1();
				register_map_table[issue_uop1.lrd] := freelist.pop1_data;
				register_status_table[issue_uop1.lrd] := BUSY;
				issue_active_list_entry.ppreg1 = register_map_table[issue_uop1.lrd];
			}
			activelist.issue(issue_active_list_entry);
			// TODO:
			finish();
		}
    }
    proc execute_alu0 {
    }
    proc execute_bru0 {
    }
    proc execute_lsu0 {
    }
    proc writeback_alu0 {
    }
    proc writeback_bru0 {
    }
    proc writeback_lsu0 {
    }
    /*
        Interrupts
    */
    func timer_interrupt_req_hart0 {
        csr.timer_interrupt_req_hart0();
    }
    func software_interrupt_req_hart0 {
        csr.software_interrupt_req_hart0();
    }

    /*
        Bus arbiter for instruction fetch unit and load store unit.
        LSU has higher priority.
    */
    {
        reg ifu_grant = 0;
        reg lsu_grant = 0;
        ifu.CLK_I = CLK_I;
        ifu.RST_I = RST_I;
        lsu.CLK_I = CLK_I;
        lsu.RST_I = RST_I;
        alt {
            lsu.CYC_O && !lsu_grant && !ifu_grant: {
                lsu_grant := 1;
                lsu.STALL_I();
                ifu.STALL_I();
            }
            ifu.CYC_O && !ifu_grant && !lsu_grant: {
                ifu_grant := 1;
                lsu.STALL_I();
                ifu.STALL_I();
            }
        }
        alt {
            lsu_grant && lsu.CYC_O && ACK_I: {
                lsu_grant := 0;
            }
            ifu_grant && ifu.CYC_O && ACK_I: {
                ifu_grant := 0;
            }
        }
        alt {
            lsu_grant: {
                ADR_O = lsu.ADR_O;
                SEL_O = lsu.SEL_O;
                DAT_O = lsu.DAT_O;
                if(lsu.CYC_O) CYC_O();
                if(lsu.STB_O) STB_O();
                if(lsu.WE_O) WE_O();
                if(lsu.LOCK_O) LOCK_O();
                lsu.DAT_I = DAT_I;
                if(ERR_I) lsu.ERR_I();
                if(RTY_I) lsu.RTY_I();
                if(STALL_I) lsu.STALL_I();
                if(ACK_I) lsu.ACK_I();
                ifu.STALL_I();
            }
            ifu_grant: {
                ADR_O = ifu.ADR_O;
                SEL_O = ifu.SEL_O;
                DAT_O = ifu.DAT_O;
                if(ifu.CYC_O) CYC_O();
                if(ifu.STB_O) STB_O();
                if(ifu.WE_O) WE_O();
                if(ifu.LOCK_O) LOCK_O();
                ifu.DAT_I = DAT_I;
                if(ERR_I) ifu.ERR_I();
                if(RTY_I) ifu.RTY_I();
                if(STALL_I) ifu.STALL_I();
                if(ACK_I) ifu.ACK_I();
                lsu.STALL_I();
            }
        }
    }
}
