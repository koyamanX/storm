#include "turboV.h"
#include "ifetch_unit.h"
#include "alu32.h"
#include "wishbone_common.h"
#include "uop_decoder.h"
#include "register_file.h"
#include "opcode_map.h"
#include "load_store_unit.h"
#include "control_status_register.h"
#include "priv.h"
#include "uops.h"
#include "reorder_buffer.h"
#include "free_list.h"
#include "issue_queue.h"
#include "issue_queue_in_order.h"

#ifdef ENABLE_DEBUG
#define DEBUG_COMMIT0(pc, inst, cause) debug_commit0(pc, inst, cause)
#define DEBUG_COMMIT1(pc, inst, cause) debug_commit1(pc, inst, cause)
#else
#define DEBUG_COMMIT0(pc, inst, cause)
#define DEBUG_COMMIT1(pc, inst, cause)
#endif

struct issue_packet_t {
	pc[XLEN];
	pred0;
	pred1;
	valid0;
	valid1;
};

module turboV {
    proc_name warm_reset();
    /* Decode stage */
    proc_name decode();
	issue_packet_t reg issue_packet;
	decoder_packet_t reg decoder_packet0;
	decoder_packet_t reg decoder_packet1;
	proc_name issue(issue_packet, decoder_packet0, decoder_packet1);
	proc_name register_read();
	reg execute_alu0_ptr[REORDER_BUFFER_PTR_SIZE];
	uop_t reg execute_alu0_uop;
	reg execute_alu0_prd[6];
	reg execute_alu0_A[32];
	reg execute_alu0_B[32];
	reg execute_alu0_X[32];
	reg execute_alu0_Y[32];
	reg execute_alu0_illegal_instruction;
	proc_name execute_alu0(execute_alu0_ptr, execute_alu0_uop, execute_alu0_prd,
			execute_alu0_A, execute_alu0_B, execute_alu0_X, execute_alu0_Y, execute_alu0_illegal_instruction);
	reg execute_alu1_ptr[REORDER_BUFFER_PTR_SIZE];
	uop_t reg execute_alu1_uop;
	reg execute_alu1_prd[6];
	reg execute_alu1_A[32];
	reg execute_alu1_B[32];
	reg execute_alu1_X[32];
	reg execute_alu1_Y[32];
	proc_name execute_alu1(execute_alu1_ptr, execute_alu1_uop, execute_alu1_prd,
			execute_alu1_A, execute_alu1_B, execute_alu1_X, execute_alu1_Y);
	proc_name execute_lsu0();
	reg writeback_alu0_ptr[REORDER_BUFFER_PTR_SIZE];
	uop_t reg writeback_alu0_uop;
	reg writeback_alu0_prd[6];
	reg writeback_alu0_q[32];
	reg writeback_alu0_target[32];
	proc_name writeback_alu0(writeback_alu0_ptr, writeback_alu0_uop, writeback_alu0_prd,
			writeback_alu0_q, writeback_alu0_target);
	reg writeback_alu1_ptr[REORDER_BUFFER_PTR_SIZE];
	uop_t reg writeback_alu1_uop;
	reg writeback_alu1_prd[6];
	reg writeback_alu1_q[32];
	reg writeback_alu1_target[32];
	proc_name writeback_alu1(writeback_alu1_ptr, writeback_alu1_uop, writeback_alu1_prd,
			writeback_alu1_q, writeback_alu1_target);
	proc_name writeback_lsu0();
	/* Pipeline flush */
	wire newpc[32];
    func_self flush(newpc);
    /* Instruction Fetch Unit */
    ifetch_unit ifu;
    /* Instruction decoder */
    uop_decoder udec0;
    uop_decoder udec1;
    /* General Purpose Register */
    register_file gpr;
    /* Load Store Unit */
    load_store_unit lsu;
    /* CSR */
    control_status_register csr;
    /* variable for generate statement */
    integer i_;
	reorder_buffer rob;
	free_list freelist;
	mem register_map_table[32][6];
	mem retirement_register_map_table[32][6];
	mem register_status_table[32][1] = {0};
	issue_queue iq_alu0;
	issue_queue iq_alu1;
	issue_queue iq_lsu0;
	alu32 alu0;
	alu32 alu1;

    func reset {
        if(!warm_reset) {
            warm_reset.invoke();
        }
    }
    proc warm_reset seq {
        {
            /* Cycle 1: Reset */
            ifu.reset();
            csr.reset();
			freelist.reset();
			generate(i_ = 0; i_ < 32; i_++) {
				register_map_table[i_] := i_;
				retirement_register_map_table[i_] := i_;
				register_status_table[i_] := READY;
			}
        }
        {
            /* Cycle 2: Start inst fetch */
            ifu.redirect(csr.trap(0, 0, 0));
            decode();
            finish();
        }
    }
    func flush {
        /* Flush all stage */
        decode.finish();
        issue.finish();
        execute_alu0.finish();
        execute_alu1.finish();
        execute_lsu0.finish();
        writeback_alu0.finish();
        writeback_alu1.finish();
        writeback_lsu0.finish();
        /* Flush ROB, RSs and LSQs */
        lsu.flush();
		/* Start decode */
        decode.invoke();
		generate(i_ = 0; i_ < 32; i_++) {
			register_map_table[i_] := retirement_register_map_table[i_];
			register_status_table[i_] := READY;
		}
		rob.flush();
		iq_alu0.flush();
		iq_alu1.flush();
		iq_lsu0.flush();
		ifu.redirect(newpc);
    }
    proc decode {
		state_name decode0, decode1;
		fetch_packet_t wire decode0_fetch_packet;
		decoder_packet_t wire decode0_decoder_packet0;
		decoder_packet_t wire decode0_decoder_packet1;
		uop_t wire decode0_uop0;
		uop_t wire decode0_uop1;
		fetch_packet_t reg decode1_fetch_packet;

		state decode0 {
			if(!ifu.ibuf_empty) {
				decode0_fetch_packet = ifu.ibuf_pop();
				udec0.decode(decode0_fetch_packet.inst0);
				udec1.decode(decode0_fetch_packet.inst1);
				decode0_decoder_packet0 = udec0.packet;
				decode0_decoder_packet1 = udec1.packet;
				decode0_uop0 = decode0_decoder_packet0.uop;
				decode0_uop1 = decode0_decoder_packet1.uop;

				if(decode0_fetch_packet.valid0 && decode0_fetch_packet.valid1) {
					/* Check if structural hazard occurs, if so, issue first insts
					   and second one goes to decode1 stage.
					any {
						else: {
							// both insts can be issued.
						}
					}
					INST0 | INST1 | issue?
					ALU   | ALU   | OK
					ALU   | LSU   | OK
					ALU   | SYSTEM| OK
					LSU   | ALU   | OK
					LSU   | LSU   | NG
					LSU   | SYSTEM| OK
					SYSTEM| ALU   | OK
					SYSTEM| LSU   | OK
					SYSTEM| SYSTEM| NG

					=> if both insts are SYSTEM or LSU, split decode into
					two stages to avoid structural hazard.
					*/
#define IS_MEMORY(uop) (uop.load || uop.store)
#define IS_SYSTEM(uop) (uop.csr || uop.mret || uop.ecall || uop.ebreak)
					if(!(IS_MEMORY(decode0_uop0) && IS_MEMORY(decode0_uop1))
							&& !(IS_SYSTEM(decode0_uop0) && IS_SYSTEM(decode0_uop1)) && (!IS_SYSTEM(decode0_uop1))) {
						// No structual hazard, issue 2 insts
						issue.invoke({decode0_fetch_packet.pc,
							decode0_fetch_packet.pred0, decode0_fetch_packet.pred1,
							decode0_fetch_packet.valid0, decode0_fetch_packet.valid1},
							udec0.packet, udec1.packet);
					} else {
						// There is structual hazard, issue first one in this cycle
						// Send another inst to issue stage in next cycle.
						// decode1 takes care of issue next inst in the cycle.
						issue.invoke({decode0_fetch_packet.pc,
							decode0_fetch_packet.pred0, 1'b0,
							decode0_fetch_packet.valid0, 1'b0},
							udec0.packet, 0);
						decode1_fetch_packet := decode0_fetch_packet;
					    goto decode1;
					}

				} else if((!decode0_fetch_packet.valid0 && decode0_fetch_packet.valid1)
					|| (decode0_fetch_packet.valid0 && !decode0_fetch_packet.valid1)) {
					// Either way0 or way1 is valid.
					// Both invalid is not enter here, ifetch_unit never pushes such case.
					// Also, currently, ifetch_unit never pushes inst1 valid && inst0 invalid.
					// TODO: 
					issue.invoke({decode0_fetch_packet.pc,
						decode0_fetch_packet.pred0, 1'b0,
						decode0_fetch_packet.valid0, 1'b0},
						udec0.packet, 0);
				}
			}
		}
		state decode1 {
			// Inst1 is either SYSTEM or LSU.
			// TODO: decode_fetch_packet
			// CAUTION: valid1, pred1, inst1
			// TODO: pc+4
			udec0.decode(decode1_fetch_packet.inst1);
			issue.invoke({decode1_fetch_packet.pc+4,
				decode1_fetch_packet.pred1, 1'b0,
				decode1_fetch_packet.valid1, 1'b0},
				udec0.packet, 0);

			goto decode0;
		}
    }
    proc issue {
		reorder_buffer_t wire issue_reorder_buffer_entry;
		wire issue_PC[30];
		// issue slot 0
		wire issue_inst0_valid;
		wire issue_inst0_ptr[REORDER_BUFFER_PTR_SIZE];
		wire issue_inst0_lrd[5];
		wire issue_inst0_prd[6];
		wire issue_inst0_pprd[6];
		wire issue_inst0_rs1_ready;
		wire issue_inst0_rs1_sel[SIZEOF_REG_SEL];
		wire issue_inst0_lrs1[5];
		wire issue_inst0_prs1[6];
		wire issue_inst0_rs2_ready;
		wire issue_inst0_rs2_sel[SIZEOF_REG_SEL];
		wire issue_inst0_lrs2[5];
		wire issue_inst0_prs2[6];
		wire issue_inst0_cause[SIZEOF_CAUSE_T];
		uop_t wire issue_inst0_uop;
		wire issue_inst0_imm[32];
		// issue slot 1
		wire issue_inst1_valid;
		wire issue_inst1_ptr[REORDER_BUFFER_PTR_SIZE];
		wire issue_inst1_lrd[5];
		wire issue_inst1_prd[6];
		wire issue_inst1_pprd[6];
		wire issue_inst1_rs1_ready;
		wire issue_inst1_rs1_sel[SIZEOF_REG_SEL];
		func_self issue_inst1_rs1_ready_bypass;
		wire issue_inst1_lrs1[5];
		wire issue_inst1_prs1[6];
		wire issue_inst1_rs2_ready;
		wire issue_inst1_rs2_sel[SIZEOF_REG_SEL];
		func_self issue_inst1_rs2_ready_bypass;
		wire issue_inst1_lrs2[5];
		wire issue_inst1_prs2[6];
		wire issue_inst1_cause[SIZEOF_CAUSE_T];
		uop_t wire issue_inst1_uop;
		wire issue_inst1_imm[32];

		issue_inst0_uop = decoder_packet0.uop;
		issue_inst1_uop = decoder_packet1.uop;
		if((freelist.count >= 2) && (!rob.full)) {
			issue_PC = issue_packet.pc[31:2];
			// inst0
			issue_inst0_valid = issue_packet.valid0;
			issue_inst0_cause = |decoder_packet0.cause;
			issue_inst0_lrd = decoder_packet0.lrd;
			issue_inst0_rs1_sel = issue_inst0_uop.rs1_sel;
			issue_inst0_lrs1 = decoder_packet0.lrs1;
			issue_inst0_rs2_sel = issue_inst0_uop.rs2_sel;
			issue_inst0_lrs2 = decoder_packet0.lrs2;
			issue_inst0_imm = decoder_packet0.imm;
			// inst1
			issue_inst1_valid = issue_packet.valid1;
			issue_inst1_cause = |decoder_packet1.cause;
			issue_inst1_lrd = decoder_packet1.lrd;
			issue_inst1_rs1_sel = issue_inst1_uop.rs1_sel;
			issue_inst1_lrs1 = decoder_packet1.lrs1;
			issue_inst1_rs2_sel = issue_inst1_uop.rs2_sel;
			issue_inst1_lrs2 = decoder_packet1.lrs2;
			issue_inst1_imm = decoder_packet1.imm;

			// Rename destination registers
			issue_inst0_pprd = register_map_table[issue_inst0_lrd];
			issue_inst1_pprd = register_map_table[issue_inst1_lrd];
			if(issue_packet.valid0 && (issue_inst0_lrd != 0)) {
				issue_inst0_prd = freelist.pop0();
				if(!(issue_packet.valid1 && (issue_inst0_lrd != 0)
							&& (issue_inst0_lrd == issue_inst1_lrd))) {
					register_map_table[issue_inst0_lrd] := issue_inst0_prd;
					register_status_table[issue_inst0_lrd] := BUSY;
				}
			}
			if(issue_packet.valid1 && (issue_inst1_lrd != 0)) {
				issue_inst1_prd = freelist.pop1();
				register_map_table[issue_inst1_lrd] := issue_inst1_prd;
				register_status_table[issue_inst1_lrd] := BUSY;
			}
			// Rename source registers
			if(issue_packet.valid0) {
				issue_inst0_prs1 = register_map_table[issue_inst0_lrs1];
				issue_inst0_prs2 = register_map_table[issue_inst0_lrs2];
			}
			if(issue_packet.valid0 && issue_packet.valid1
					&& issue_inst0_lrd == issue_inst1_lrs1 && issue_inst0_uop.rd_valid && issue_inst1_uop.rs1_valid) {
				issue_inst1_prs1 = issue_inst0_prd;
				issue_inst1_rs1_ready_bypass();
			} else {
				issue_inst1_prs1 = register_map_table[issue_inst1_lrs1];
			}
			if(issue_packet.valid0 && issue_packet.valid1
					&& issue_inst0_lrd == issue_inst1_lrs2 && issue_inst0_uop.rd_valid && issue_inst1_uop.rs2_valid) {
				issue_inst1_prs2 = issue_inst0_prd;
				issue_inst1_rs2_ready_bypass();
			} else {
				issue_inst1_prs2 = register_map_table[issue_inst1_lrs2];
			}
			// Source register ready
			if(!issue_inst0_uop.rs1_valid) {
				issue_inst0_rs1_ready = READY;
			} else {
				issue_inst0_rs1_ready = issue_packet.valid0 && register_status_table[issue_inst0_lrs1];
			}
			if(!issue_inst0_uop.rs2_valid) {
				issue_inst0_rs2_ready = READY;
			} else {
				issue_inst0_rs2_ready = issue_packet.valid0 && register_status_table[issue_inst0_lrs2];
			}
			if(!issue_inst1_uop.rs1_valid) {
				issue_inst1_rs1_ready = READY;
			} else if(issue_inst1_rs1_ready_bypass) {
				issue_inst1_rs1_ready = BUSY;
			} else {
				issue_inst1_rs1_ready = issue_packet.valid1 && register_status_table[issue_inst1_lrs1];
			}
			if(!issue_inst1_uop.rs2_valid) {
				issue_inst1_rs2_ready = READY;
			} else if(issue_inst1_rs2_ready_bypass) {
				issue_inst1_rs2_ready = BUSY;
			} else {
				issue_inst1_rs2_ready = issue_packet.valid1 && register_status_table[issue_inst1_lrs2];
			}

#ifdef ENABLE_DEBUG
			rob.issue(issue_PC,
					issue_inst0_valid, issue_inst0_uop, issue_inst0_lrd, issue_inst0_prd, issue_inst0_pprd, issue_inst0_cause,
					issue_inst1_valid, issue_inst1_uop, issue_inst1_lrd, issue_inst1_prd, issue_inst1_pprd, issue_inst1_cause,
					decoder_packet0.inst, decoder_packet1.inst);
#else
			rob.issue(issue_PC,
					issue_inst0_valid, issue_inst0_uop, issue_inst0_lrd, issue_inst0_prd, issue_inst0_pprd, issue_inst0_cause,
					issue_inst1_valid, issue_inst1_uop, issue_inst1_lrd, issue_inst1_prd, issue_inst1_pprd, issue_inst1_cause);
#endif
			// TODO: NSL does not support mod.sig_o[_int(N)]
			issue_inst0_ptr = rob.ptr;
			issue_inst1_ptr = rob.ptr+1;

			// TODO:
			if(issue_inst0_valid) {
				any {
					issue_inst0_uop.store || issue_inst0_uop.load: {
						iq_lsu0.issue(issue_inst0_ptr, issue_inst0_uop, issue_inst0_prd,
								issue_inst0_rs1_ready, issue_inst0_prs1,
								issue_inst0_rs2_ready, issue_inst0_prs2,
								issue_inst0_imm);
					}
					else: {
						iq_alu0.issue(issue_inst0_ptr, issue_inst0_uop, issue_inst0_prd,
								issue_inst0_rs1_ready, issue_inst0_prs1,
								issue_inst0_rs2_ready, issue_inst0_prs2,
								issue_inst0_imm);
					 }
				}
			}
			// TODO:
			if(issue_inst1_valid) {
				any {
					issue_inst1_uop.store || issue_inst1_uop.load: {
						iq_lsu0.issue(issue_inst1_ptr, issue_inst1_uop, issue_inst1_prd,
							issue_inst1_rs1_ready, issue_inst1_prs1,
							issue_inst1_rs2_ready, issue_inst1_prs2,
							issue_inst1_imm);
					}
					else: {
						iq_alu1.issue(issue_inst1_ptr, issue_inst1_uop, issue_inst1_prd,
							issue_inst1_rs1_ready, issue_inst1_prs1,
							issue_inst1_rs2_ready, issue_inst1_prs2,
							issue_inst1_imm);
					}
				}
			}
			// TODO:
			finish();
		}
    }
	func iq_alu0.dispatch {
		wire iq_alu0_A[32];
		wire iq_alu0_B[32];
		wire iq_alu0_PC[32];
		uop_t wire iq_alu0_uop;

		iq_alu0_uop = iq_alu0.dispatch_uop;
		iq_alu0_PC = rob.readPC0(iq_alu0.dispatch_ptr);
		// SYSTEM instruction is dispatched in this pipe.
		any {
			iq_alu0_uop.rs1_sel == RS1_SEL_REG && iq_alu0_uop.rs1_valid: iq_alu0_A = gpr.readA(iq_alu0.dispatch_prs1);
			iq_alu0_uop.rs1_sel == RS1_SEL_REG && !iq_alu0_uop.rs1_valid: iq_alu0_A = 0;
			iq_alu0_uop.rs1_sel == RS1_SEL_UIMM: iq_alu0_A = iq_alu0.dispatch_imm[4:0];
			iq_alu0_uop.rs1_sel == RS1_SEL_PC: iq_alu0_A = iq_alu0_PC;
		}
		any {
			iq_alu0_uop.rs2_sel == RS2_SEL_REG && iq_alu0_uop.rs2_valid: iq_alu0_B = gpr.readB(iq_alu0.dispatch_prs2);
			iq_alu0_uop.rs2_sel == RS2_SEL_REG && !iq_alu0_uop.rs2_valid: iq_alu0_B = 0;
			iq_alu0_uop.rs2_sel == RS2_SEL_IMM: iq_alu0_B = iq_alu0.dispatch_imm;
			iq_alu0_uop.rs2_sel == RS2_SEL_CSR: iq_alu0_B = csr.read(iq_alu0.dispatch_imm);
			iq_alu0_uop.rs2_sel == RS2_SEL_CSR_UIMM: iq_alu0_B = csr.read(iq_alu0.dispatch_imm) & 0xffffffe0;
		}
		/*
			For branch instruction, branch target is already calculated in decode stage,
			only branch condition need to be calculated. 
				rs1_sel == REG, rs2_sel == REG, PC+imm
				alu_A = REG, alu_B = REG, PC, imm
				no writeback
			For JAL instruction, target is already calculated in decode stage (PC+imm),
				rs1_sel == REG(x0), rs2_sel == IMM(PC+imm), PC+4
				writeback PC+4
				alu_A = PC, alu_B = 4, PC, 4
			For JALR instruction, target address need to be calculated in execute stage(rs1+imm)
				rs1_sel == REG, rs2_sel == IMM, PC+4
				writeback PC+4
				alu_A = PC, alu_B = 4, REG, IMM
			For JAL and JALR instruction, write PC+4 to rd register.
	   */
		if(iq_alu0_uop.branch) {
			execute_alu0.invoke(iq_alu0.dispatch_ptr, iq_alu0_uop, iq_alu0.dispatch_prd,
					iq_alu0_A, iq_alu0_B, iq_alu0_PC, iq_alu0.dispatch_imm, 0);
		} else if(iq_alu0_uop.jal) {
			execute_alu0.invoke(iq_alu0.dispatch_ptr, iq_alu0_uop, iq_alu0.dispatch_prd,
					iq_alu0_PC, 4, iq_alu0_PC, iq_alu0.dispatch_imm, 0);
		} else if(iq_alu0_uop.jalr) {
			execute_alu0.invoke(iq_alu0.dispatch_ptr, iq_alu0_uop, iq_alu0.dispatch_prd,
					iq_alu0_PC, 4, iq_alu0_A, iq_alu0.dispatch_imm, 0);
		} else if(iq_alu0_uop.csr) {
			execute_alu0.invoke(iq_alu0.dispatch_ptr, iq_alu0_uop, iq_alu0.dispatch_prd,
					iq_alu0_A, iq_alu0_B, iq_alu0.dispatch_imm, 0, SET_EXCEPTION(ILLEGAL_INSTRUCTION, csr.read_error));
		} else {
			execute_alu0.invoke(iq_alu0.dispatch_ptr, iq_alu0_uop, iq_alu0.dispatch_prd,
					iq_alu0_A, iq_alu0_B, 0, 0, 0);
		}
	}
    proc execute_alu0 {
		alu0.exe(execute_alu0_A, execute_alu0_B, execute_alu0_uop.uop[FN_SIZE-1:0]);
		writeback_alu0(execute_alu0_ptr, execute_alu0_uop, execute_alu0_prd, alu0.q, execute_alu0_X+execute_alu0_Y);
    }
	func iq_alu1.dispatch {
		wire iq_alu1_A[32];
		wire iq_alu1_B[32];
		wire iq_alu1_PC[32];
		uop_t wire iq_alu1_uop;
		// SYSTEM instruction never dispatched here.

		iq_alu1_uop = iq_alu1.dispatch_uop;
		iq_alu1_PC = rob.readPC1(iq_alu1.dispatch_ptr);
		any {
			iq_alu1_uop.rs1_sel == RS1_SEL_REG && iq_alu1_uop.rs1_valid: iq_alu1_A = gpr.readC(iq_alu1.dispatch_prs1);
			iq_alu1_uop.rs1_sel == RS1_SEL_REG && !iq_alu1_uop.rs1_valid: iq_alu1_A = 0;
			iq_alu1_uop.rs1_sel == RS1_SEL_PC: iq_alu1_A = iq_alu1_PC;
		}
		any {
			iq_alu1_uop.rs2_sel == RS2_SEL_REG && iq_alu1_uop.rs2_valid: iq_alu1_B = gpr.readD(iq_alu1.dispatch_prs2);
			iq_alu1_uop.rs2_sel == RS2_SEL_REG && !iq_alu1_uop.rs2_valid: iq_alu1_B = 0;
			iq_alu1_uop.rs2_sel == RS2_SEL_IMM: iq_alu1_B = iq_alu1.dispatch_imm;
		}
		if(iq_alu1_uop.branch) {
			execute_alu1.invoke(iq_alu1.dispatch_ptr, iq_alu1_uop, iq_alu1.dispatch_prd,
					iq_alu1_A, iq_alu1_B, iq_alu1_PC, iq_alu1.dispatch_imm);
		} else if(iq_alu1_uop.jal) {
			execute_alu1.invoke(iq_alu1.dispatch_ptr, iq_alu1_uop, iq_alu1.dispatch_prd,
					iq_alu1_PC, 4, iq_alu1_PC, iq_alu1.dispatch_imm);
		} else if(iq_alu1_uop.jalr) {
			execute_alu1.invoke(iq_alu1.dispatch_ptr, iq_alu1_uop, iq_alu1.dispatch_prd,
					iq_alu1_PC, 4, iq_alu1_A, iq_alu1.dispatch_imm);
		} else {
			execute_alu1.invoke(iq_alu1.dispatch_ptr, iq_alu1_uop, iq_alu1.dispatch_prd,
					iq_alu1_A, iq_alu1_B, 0, 0);
		}
	}
    proc execute_alu1 {
		alu1.exe(execute_alu1_A, execute_alu1_B, execute_alu1_uop.uop[FN_SIZE-1:0]);
		writeback_alu1(execute_alu1_ptr, execute_alu1_uop, execute_alu1_prd, alu1.q, execute_alu1_X+execute_alu1_Y);
    }
    proc execute_lsu0 {
    }
    proc writeback_alu0 {
		if(writeback_alu0_uop.rd_valid) {
			gpr.writeA(writeback_alu0_prd, writeback_alu0_q);
			iq_alu0.wakeup0(writeback_alu0_prd);
			iq_alu1.wakeup0(writeback_alu0_prd);
			iq_lsu0.wakeup0(writeback_alu0_prd);
			register_status_table[writeback_alu0_prd] := READY;
		}
		if(writeback_alu0_uop.branch) {
			rob.complete_alu0(writeback_alu0_ptr, writeback_alu0_q, writeback_alu0_target, 0);
		} else if(writeback_alu0_uop.jal || writeback_alu0_uop.jalr) {
			rob.complete_alu0(writeback_alu0_ptr, 1, writeback_alu0_target, 0);
		} else if(writeback_alu0_uop.csr) {
			if(writeback_alu0_uop.csr_write) {
				csr.write(rob.head_ptr, writeback_alu0_ptr, writeback_alu0_target, writeback_alu0_q);
			}
			rob.complete_alu0(writeback_alu0_ptr, 0, 0, csr.write_error);
		} else {
			rob.complete_alu0(writeback_alu0_ptr, 0, 0, 0);
		}
		finish();
    }
    proc writeback_alu1 {
		if(writeback_alu1_uop.rd_valid) {
			gpr.writeB(writeback_alu1_prd, writeback_alu1_q);
			iq_alu0.wakeup1(writeback_alu1_prd);
			iq_alu1.wakeup1(writeback_alu1_prd);
			iq_lsu0.wakeup1(writeback_alu1_prd);
			register_status_table[writeback_alu1_prd] := READY;
		}
		if(writeback_alu1_uop.branch) {
			rob.complete_alu1(writeback_alu1_ptr, writeback_alu1_q, writeback_alu1_target);
		} else if(writeback_alu1_uop.jal || writeback_alu1_uop.jalr) {
			rob.complete_alu1(writeback_alu1_ptr, 1, writeback_alu1_target);
		} else {
			rob.complete_alu1(writeback_alu1_ptr, 0, 0);
		}
		finish();
    }
    proc writeback_lsu0 {
    }
	func rob.commitable {
		reorder_buffer_t wire commit_entry;
		uop_t wire commit_uop0;
		uop_t wire commit_uop1;
		wire commit_PC0[32];
		wire commit_PC1[32];
		func_self commit_kill;

		commit_entry = rob.commit();
		commit_uop0 = commit_entry.uop0;
		commit_uop1 = commit_entry.uop1;
		commit_PC0 = {commit_entry.PC, 2'b00};
		commit_PC1 = {commit_entry.PC, 2'b00}+4;

		if(commit_entry.valid0) {
			if(commit_uop0.rd_valid) {
				freelist.push0(commit_entry.ppreg0);
				retirement_register_map_table[commit_entry.dreg0] := commit_entry.preg0;
			}
			if(commit_uop0.csr_write) {
				csr.commit(rob.head_ptr);
				flush(commit_PC0+4);
				commit_kill();
			}
			if(commit_uop0.ecall) {
				csr.trap(ENVIRONMENT_CALL_FROM_M_MODE, commit_PC0+4, 0);
				flush();
				commit_kill();
			}
			if(commit_uop0.ebreak) {
				csr.trap(BREAKPOINT, commit_PC0, 0);
				flush();
				commit_kill();
			}
			if(commit_uop0.mret) {
				flush(csr.mret());
				commit_kill();
			}
			if(commit_uop0.jal || commit_uop0.jalr || (commit_uop0.branch && commit_entry.taken0)) {
				flush(commit_entry.target0);
				commit_kill();
			}
			DEBUG_COMMIT0(commit_PC0, commit_entry.inst0, commit_entry.cause0);
		}
		if(commit_entry.valid1 && !commit_kill) {
			if(commit_uop1.rd_valid) {
				freelist.push1(commit_entry.ppreg1);
				retirement_register_map_table[commit_entry.dreg1] := commit_entry.preg1;
			}
			if(commit_uop1.jal || commit_uop1.jalr || (commit_uop1.branch && commit_entry.taken1)) {
				flush(commit_entry.target1);
			}
			DEBUG_COMMIT1(commit_PC1, commit_entry.inst1, commit_entry.cause1);
		}
	}
    /*
        Interrupts
    */
    func timer_interrupt_req_hart0 {
        csr.timer_interrupt_req_hart0();
    }
    func software_interrupt_req_hart0 {
        csr.software_interrupt_req_hart0();
    }

    /*
        Bus arbiter for instruction fetch unit and load store unit.
        LSU has higher priority.
    */
    {
        reg ifu_grant = 0;
        reg lsu_grant = 0;
        ifu.CLK_I = CLK_I;
        ifu.RST_I = RST_I;
        lsu.CLK_I = CLK_I;
        lsu.RST_I = RST_I;
        alt {
            lsu.CYC_O && !lsu_grant && !ifu_grant: {
                lsu_grant := 1;
                lsu.STALL_I();
                ifu.STALL_I();
            }
            ifu.CYC_O && !ifu_grant && !lsu_grant: {
                ifu_grant := 1;
                lsu.STALL_I();
                ifu.STALL_I();
            }
        }
        alt {
            lsu_grant && lsu.CYC_O && ACK_I: {
                lsu_grant := 0;
            }
            ifu_grant && ifu.CYC_O && ACK_I: {
                ifu_grant := 0;
            }
        }
        alt {
            lsu_grant: {
                ADR_O = lsu.ADR_O;
                SEL_O = lsu.SEL_O;
                DAT_O = lsu.DAT_O;
                if(lsu.CYC_O) CYC_O();
                if(lsu.STB_O) STB_O();
                if(lsu.WE_O) WE_O();
                if(lsu.LOCK_O) LOCK_O();
                lsu.DAT_I = DAT_I;
                if(ERR_I) lsu.ERR_I();
                if(RTY_I) lsu.RTY_I();
                if(STALL_I) lsu.STALL_I();
                if(ACK_I) lsu.ACK_I();
                ifu.STALL_I();
            }
            ifu_grant: {
                ADR_O = ifu.ADR_O;
                SEL_O = ifu.SEL_O;
                DAT_O = ifu.DAT_O;
                if(ifu.CYC_O) CYC_O();
                if(ifu.STB_O) STB_O();
                if(ifu.WE_O) WE_O();
                if(ifu.LOCK_O) LOCK_O();
                ifu.DAT_I = DAT_I;
                if(ERR_I) ifu.ERR_I();
                if(RTY_I) ifu.RTY_I();
                if(STALL_I) ifu.STALL_I();
                if(ACK_I) ifu.ACK_I();
                lsu.STALL_I();
            }
        }
    }
}
