#include "load_store_unit.h"
#include "load_queue.h"
#include "wishbone_master.h"
#include "uops.h"

module load_store_unit {
    wishbone_master wb_master_if;
    reg memory_A[32];
    reg memory_Data[32];
    reg memory_uOp[7];
    reg memory_RobId[ROB_TAG_SIZE];
    reg stqV = 0;
    proc_name memory(memory_A, memory_Data, memory_uOp, memory_RobId);

    func issue {
        if(issue_uOp == uOP_LOAD_WORD) {
            memory(issue_A, 0, issue_uOp, issue_RobId);
        } else if(issue_uOp == uOP_STORE_WORD) {
            stqV := 1;
            memory_A := issue_A;
            memory_Data := issue_Vj;
            memory_uOp := issue_uOp;
            memory_RobId := issue_RobId;
        }
    }
    if(!flush && (memory || stqV)) {
        full();
    }
    proc memory {
        state_name memory_req, memory_wait;

        state memory_req {
            if(memory_uOp == uOP_LOAD_WORD) {
                wb_master_if.req_read(memory_A, 0xff);
            } else if(memory_uOp == uOP_STORE_WORD) {
                wb_master_if.req_write(memory_A, 0xff, memory_Data);
            }
            if(wb_master_if.rsp_valid) {
                if(memory_uOp == uOP_LOAD_WORD) {
                    CDBOut(memory_RobId, wb_master_if.rsp_data);
                }
                finish();
            } else {
                goto memory_wait;
            }
        }
        state memory_wait {
            if(wb_master_if.rsp_valid) {
                if(memory_uOp == uOP_LOAD_WORD) {
                    CDBOut(memory_RobId, wb_master_if.rsp_data);
                }
                finish();
                goto memory_req;
            }
        }
        stall();
    }
    func flush {
        stqV := 0;
    }
    func commit {
        /* Do not check if(!flush) here, if flush is needed, do not assert commit */
        stqV := 0;
        memory(memory_A, memory_Data, memory_uOp, memory_RobId);
    }
    WISHBONE_MASTER_IF(wb_master_if);
}
