#include "storm.h"
#include "ifetch_unit.h"
#include "alu32.h"
#include "wishbone_common.h"
#include "reorder_buffer.h"
#include "instruction_decoder.h"
#include "reservation_station.h"
#include "register_file.h"

module storm {
	ifetch_unit ifu;
	reorder_buffer rob;
	reservation_station alu_rs;
	instruction_decoder idec;
	register_file gpr;
	proc_name decode();
	func_self stall_issue();
	mem register_map_table[32][6] = {0};
	mem register_status_table[32][1] = {0};
	fetch_packet_t reg issue_fetch_packet;
	reg issue_inst0_op[7];
	reg issue_inst0_rd[5];
	reg issue_inst0_rs1[5];
	reg issue_inst0_rs2[5];
	reg issue_inst0_imm[32];
	reg issue_inst1_op[7];
	reg issue_inst1_rd[5];
	reg issue_inst1_rs1[5];
	reg issue_inst1_rs2[5];
	reg issue_inst1_imm[32];
	proc_name issue(issue_fetch_packet,
		issue_inst0_op, issue_inst0_rd, issue_inst0_rs1, issue_inst0_rs2, issue_inst0_imm,
		issue_inst1_op, issue_inst1_rd, issue_inst1_rs1, issue_inst1_rs2, issue_inst1_imm
	);
	reg execute_alu0_fn[4];
	reg execute_alu0_dest[6];
	reg execute_alu0_a[32];
	reg execute_alu0_b[32];
	reg execute_alu1_fn[4];
	reg execute_alu1_dest[6];
	reg execute_alu1_a[32];
	reg execute_alu1_b[32];
	proc_name execute_alu0(execute_alu0_fn, execute_alu0_dest, execute_alu0_a, execute_alu0_b);
	proc_name execute_alu1(execute_alu1_fn, execute_alu1_dest, execute_alu1_a, execute_alu1_b);
	reg writeresult_alu0_dest[6];
	reg writeresult_alu0_val[32];
	reg writeresult_alu1_dest[6];
	reg writeresult_alu1_val[32];
	proc_name writeresult_alu0(writeresult_alu0_dest, writeresult_alu0_val);
	proc_name writeresult_alu1(writeresult_alu1_dest, writeresult_alu1_val);

	func reset {
		ifu.reset();
		ifu.redirect(resetvector);
		decode();
	}
	proc decode {
		fetch_packet_t wire decode_fetch_packet;
		if(!ifu.ibuf_empty && !stall_issue) {
			decode_fetch_packet = ifu.ibuf_pop();
			idec.decode(decode_fetch_packet.inst0, decode_fetch_packet.inst1);	
			decode();
			issue(decode_fetch_packet, idec.uops0, idec.uops0_rd, idec.uops0_rs1, idec.uops0_rs2, idec.uops0_imm,
								idec.uops1, idec.uops1_rd, idec.uops1_rs1, idec.uops1_rs2, idec.uops1_imm);
		}
	}
	proc issue {
		wire issue_inst0_Qj[LOG2_ROB_NUM_OF_ENTRIES];
		wire issue_inst0_Qk[LOG2_ROB_NUM_OF_ENTRIES];
		wire issue_inst0_Vj[32];
		wire issue_inst0_Vk[32];
		wire issue_inst1_Qj[LOG2_ROB_NUM_OF_ENTRIES];
		wire issue_inst1_Qk[LOG2_ROB_NUM_OF_ENTRIES];
		wire issue_inst1_Vj[32];
		wire issue_inst1_Vk[32];

		if(!rob.full && !alu_rs.full) {
			/* inst0 rs1 read */
			if(register_status_table[issue_inst0_rs1] == BUSY) {
				if(rob.read_operandA(register_map_table[issue_inst0_rs1]) == BUSY) {
					/* Wait for inst in ROB to produce value */
					issue_inst0_Vj = 0;
					issue_inst0_Qj = register_map_table[issue_inst0_rs1];
				} else {
					/* Use value inside ROB */
					issue_inst0_Vj = rob.read_operandA_val;
					issue_inst0_Qj = 0;
				}
			} else {
				issue_inst0_Vj = gpr.readA(issue_inst0_rs1);
				issue_inst0_Qj = 0;
			}
			/* inst0 rs2 read */
			if(register_status_table[issue_inst0_rs2] == BUSY) {
				if(rob.read_operandB(register_map_table[issue_inst0_rs2]) == BUSY) {
					/* Wait for inst in ROB to produce value */
					issue_inst0_Vk = 0;
					issue_inst0_Qk = register_map_table[issue_inst0_rs2];
				} else {
					/* Use value inside ROB */
					issue_inst0_Vk = rob.read_operandB_val;
					issue_inst0_Qk = 0;
				}
			} else {
				issue_inst0_Vk = gpr.readB(issue_inst0_rs1);
				issue_inst0_Qk = 0;
			}
			/* inst1 rs1 read */
			if(issue_inst0_rd == issue_inst1_rs1) {
				issue_inst1_Vj = 0;
				issue_inst1_Qj = rob.tag;
			} else {
				if(register_status_table[issue_inst1_rs1] == BUSY) {
					if(rob.read_operandC(register_map_table[issue_inst1_rs1]) == BUSY) {
						/* Wait for inst in ROB to produce value */
						issue_inst1_Vj = 0;
						issue_inst1_Qj = register_map_table[issue_inst1_rs1];
					} else {
						/* Use value inside ROB */
						issue_inst1_Vj = rob.read_operandC_val;
						issue_inst1_Qj = 0;
					}
				} else {
					issue_inst1_Vj = gpr.readC(issue_inst1_rs1);
					issue_inst1_Qj = 0;
				}
			}
			/* inst1 rs2 read */
			if(issue_inst0_rd == issue_inst1_rs2) {
				issue_inst1_Vj = 0;
				issue_inst1_Qj = rob.tag;
			} else {
				if(register_status_table[issue_inst1_rs2] == BUSY) {
					if(rob.read_operandD(register_map_table[issue_inst1_rs2]) == BUSY) {
						/* Wait for inst in ROB to produce value */
						issue_inst1_Vk = 0;
						issue_inst1_Qk = register_map_table[issue_inst1_rs2];
					} else {
						/* Use value inside ROB */
						issue_inst1_Vk = rob.read_operandD_val;
						issue_inst1_Qk = 0;
					}
				} else {
					issue_inst1_Vk = gpr.readD(issue_inst1_rs1);
					issue_inst1_Qk = 0;
				}
			}
			rob.push(
				issue_fetch_packet.valid0, issue_fetch_packet.pc0, issue_fetch_packet.inst0, issue_inst0_rd,
				issue_fetch_packet.valid1, issue_fetch_packet.pc1, issue_fetch_packet.inst1, issue_inst1_rd
			);
			alu_rs.issue(
				issue_fetch_packet.valid0, issue_inst0_op, issue_inst0_Vj, issue_inst0_Vk, issue_inst0_Qj, issue_inst0_Qk, rob.tag, 0,
				issue_fetch_packet.valid1, issue_inst1_op, issue_inst1_Vj, issue_inst1_Vk, issue_inst1_Qj, issue_inst1_Qk, rob.tag+1, 0
			);
			/* inst0 rd mapping */
			if(issue_inst0_rd != 0) {
				register_map_table[issue_inst0_rd] := rob.tag;
				register_status_table[issue_inst0_rd] := BUSY;
			}
			/* inst1 rd mapping */
			if(issue_inst1_rd != 0) {
				register_map_table[issue_inst1_rd] := rob.tag+1;
				register_status_table[issue_inst1_rd] := BUSY;
			}
			finish();
		} else {
			stall_issue();
		}
	}
	func alu_rs.dispatch0 {
		execute_alu0.invoke(alu_rs.dispatch0_Op, alu_rs.dispatch0_Dest, alu_rs.dispatch0_Vj, alu_rs.dispatch0_Vk);
	}
	func alu_rs.dispatch1 {
		execute_alu1.invoke(alu_rs.dispatch1_Op, alu_rs.dispatch1_Dest, alu_rs.dispatch1_Vj, alu_rs.dispatch1_Vk);
	}
	proc execute_alu0 {
		alu32 alu0;

		alu0.exe(execute_alu0_a, execute_alu0_b, execute_alu0_fn);
		writeresult_alu0(execute_alu0_dest, alu0.q);
	}
	proc execute_alu1 {
		alu32 alu1;

		alu1.exe(execute_alu1_a, execute_alu1_b, execute_alu1_fn);
		writeresult_alu1(execute_alu1_dest, alu1.q);
	}
	proc writeresult_alu0 {
		alu_rs.CDB0(writeresult_alu0_dest, writeresult_alu0_val);
		rob.CDB0(writeresult_alu0_dest, writeresult_alu0_val);
		finish();
	}
	proc writeresult_alu1 {
		alu_rs.CDB1(writeresult_alu1_dest, writeresult_alu1_val);
		rob.CDB1(writeresult_alu1_dest, writeresult_alu1_val);
		finish();
	}
	func rob.commit {
		if(issue && (issue_inst0_rd != rob.commit_Dest0)) {
			register_status_table[rob.commit_Dest0] := READY;
		}
		if(issue && (issue_inst1_rd != rob.commit_Dest1)) {
			register_status_table[rob.commit_Dest1] := READY;
		}
		gpr.writeA(rob.commit_Dest0, rob.commit_Value0);
		gpr.writeB(rob.commit_Dest1, rob.commit_Value1);
	}

	WISHBONE_MASTER_IF(ifu);
}
