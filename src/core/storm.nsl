#include "storm.h"
#include "ifetch_unit.h"
#include "alu32.h"
#include "wishbone_common.h"
#include "reorder_buffer.h"
#include "instruction_decoder.h"
#include "reservation_station.h"
#include "register_file.h"

module storm {
	ifetch_unit ifu;
	reorder_buffer rob;
	reservation_station alu_rs0;
	reservation_station alu_rs1;
	instruction_decoder idec0;
	instruction_decoder idec1;
	register_file gpr;
	proc_name decode();
	func_self stall_issue();
	mem register_map_table[32][ROB_TAG_SIZE] = {0};
	mem register_status_table[32][1] = {0};
	fetch_packet_t reg issue_fetch_packet;
	reg issue_inst0_op[7];
	reg issue_inst0_rd[5];
	reg issue_inst0_rs1_sel[2];
	reg issue_inst0_rs1[5];
	reg issue_inst0_rs2_sel[2];
	reg issue_inst0_rs2[5];
	reg issue_inst0_imm[32];
	reg issue_inst1_op[7];
	reg issue_inst1_rd[5];
	reg issue_inst1_rs1_sel[2];
	reg issue_inst1_rs1[5];
	reg issue_inst1_rs2_sel[2];
	reg issue_inst1_rs2[5];
	reg issue_inst1_imm[32];
	proc_name issue(issue_fetch_packet,
		issue_inst0_op, issue_inst0_rd, issue_inst0_rs1_sel, issue_inst0_rs1, issue_inst0_rs2_sel, issue_inst0_rs2, issue_inst0_imm,
		issue_inst1_op, issue_inst1_rd, issue_inst1_rs1_sel, issue_inst1_rs1, issue_inst1_rs2_sel, issue_inst1_rs2, issue_inst1_imm
	);
	reg execute_alu0_fn[4];
	reg execute_alu0_dest[ROB_TAG_SIZE];
	reg execute_alu0_a[32];
	reg execute_alu0_b[32];
	reg execute_alu1_fn[4];
	reg execute_alu1_dest[ROB_TAG_SIZE];
	reg execute_alu1_a[32];
	reg execute_alu1_b[32];
	proc_name execute_alu0(execute_alu0_fn, execute_alu0_dest, execute_alu0_a, execute_alu0_b);
	proc_name execute_alu1(execute_alu1_fn, execute_alu1_dest, execute_alu1_a, execute_alu1_b);
	reg writeresult_alu0_dest[ROB_TAG_SIZE];
	reg writeresult_alu0_val[32];
	reg writeresult_alu1_dest[ROB_TAG_SIZE];
	reg writeresult_alu1_val[32];
	proc_name writeresult_alu0(writeresult_alu0_dest, writeresult_alu0_val);
	proc_name writeresult_alu1(writeresult_alu1_dest, writeresult_alu1_val);

	func reset {
		ifu.reset();
		ifu.redirect(resetvector);
		decode();
	}
	proc decode {
		fetch_packet_t wire decode_fetch_packet;
		if(!ifu.ibuf_empty && !stall_issue) {
			decode_fetch_packet = ifu.ibuf_pop();
			idec0.decode(decode_fetch_packet.inst0);
			idec1.decode(decode_fetch_packet.inst1);
			decode();
			issue(decode_fetch_packet,
					idec0.uops, idec0.uops_rd, idec0.uops_rs1_sel, idec0.uops_rs1, idec0.uops_rs2_sel, idec0.uops_rs2, idec0.uops_imm,
					idec1.uops, idec1.uops_rd, idec1.uops_rs1_sel, idec1.uops_rs1, idec1.uops_rs2_sel, idec1.uops_rs2, idec1.uops_imm
			);
		}
	}
	proc issue {
		wire issue_inst0_Qj[ROB_TAG_SIZE];
		wire issue_inst0_Qk[ROB_TAG_SIZE];
		wire issue_inst0_Vj[32];
		wire issue_inst0_Vk[32];
		wire issue_inst1_Qj[ROB_TAG_SIZE];
		wire issue_inst1_Qk[ROB_TAG_SIZE];
		wire issue_inst1_Vj[32];
		wire issue_inst1_Vk[32];

		if(!rob.full && !alu_rs0.full && !alu_rs1.full) {
			/* inst0 rs1 read */
			if(issue_inst0_rs1_sel == RS_SEL_ZERO) {
				issue_inst0_Vj = 0;
				issue_inst0_Qj = 0;
			} else if(issue_inst0_rs1_sel == RS_SEL_PC) {
				issue_inst0_Vj = issue_fetch_packet.pc0;
				issue_inst0_Qj = 0;
			} else {
				if(issue_inst0_rs1 == 5'b00000) {
					issue_inst0_Vj = 0;
					issue_inst0_Qj = 0;
				} else if(register_status_table[issue_inst0_rs1] == BUSY) {
					if(rob.read_operandA(register_map_table[issue_inst0_rs1]) == BUSY) {
						/* Wait for inst in ROB to produce value */
						issue_inst0_Vj = 0;
						issue_inst0_Qj = register_map_table[issue_inst0_rs1];
					} else {
						/* Use value inside ROB */
						issue_inst0_Vj = rob.read_operandA_val;
						issue_inst0_Qj = 0;
					}
				} else {
					issue_inst0_Vj = gpr.readA(issue_inst0_rs1);
					issue_inst0_Qj = 0;
				}
			}
			/* inst0 rs2 read */
			if(issue_inst0_rs2_sel == RS_SEL_REG) {
				if(issue_inst0_rs2 == 5'b00000) {
					issue_inst0_Vk = 0;
					issue_inst0_Qk = 0;
				} else if(register_status_table[issue_inst0_rs2] == BUSY) {
					if(rob.read_operandB(register_map_table[issue_inst0_rs2]) == BUSY) {
						/* Wait for inst in ROB to produce value */
						issue_inst0_Vk = 0;
						issue_inst0_Qk = register_map_table[issue_inst0_rs2];
					} else {
						/* Use value inside ROB */
						issue_inst0_Vk = rob.read_operandB_val;
						issue_inst0_Qk = 0;
					}
				} else {
					issue_inst0_Vk = gpr.readB(issue_inst0_rs1);
					issue_inst0_Qk = 0;
				}
			} else if(issue_inst0_rs2_sel == RS_SEL_IMM) {
				issue_inst0_Vk = issue_inst0_imm;
				issue_inst0_Qk = 0;
			}
			/* inst1 rs1 read */
			if(issue_inst1_rs1_sel == RS_SEL_ZERO) {
				issue_inst1_Vj = 0;
				issue_inst1_Qj = 0;
			} else if(issue_inst1_rs1_sel == RS_SEL_PC) {
				issue_inst1_Vj = issue_fetch_packet.pc1;
				issue_inst1_Qj = 0;
			} else {
				if(issue_inst1_rs1 == 5'b00000) {
					issue_inst1_Vj = 0;
					issue_inst1_Qj = 0;
				} else if(issue_inst0_rd == issue_inst1_rs1) {
					issue_inst1_Vj = 0;
					issue_inst1_Qj = rob.tag;
				} else {
					if(register_status_table[issue_inst1_rs1] == BUSY) {
						if(rob.read_operandC(register_map_table[issue_inst1_rs1]) == BUSY) {
							/* Wait for inst in ROB to produce value */
							issue_inst1_Vj = 0;
							issue_inst1_Qj = register_map_table[issue_inst1_rs1];
						} else {
							/* Use value inside ROB */
							issue_inst1_Vj = rob.read_operandC_val;
							issue_inst1_Qj = 0;
						}
					} else {
						issue_inst1_Vj = gpr.readC(issue_inst1_rs1);
						issue_inst1_Qj = 0;
					}
				}
			}
			/* inst1 rs2 read */
			if(issue_inst1_rs2_sel == RS_SEL_REG) {
				if(issue_inst1_rs2 == 5'b00000) {
					issue_inst1_Vk = 0;
					issue_inst1_Qk = 0;
				} else if(issue_inst0_rd == issue_inst1_rs2) {
					issue_inst1_Vj = 0;
					issue_inst1_Qj = rob.tag;
				} else {
					if(register_status_table[issue_inst1_rs2] == BUSY) {
						if(rob.read_operandD(register_map_table[issue_inst1_rs2]) == BUSY) {
							/* Wait for inst in ROB to produce value */
							issue_inst1_Vk = 0;
							issue_inst1_Qk = register_map_table[issue_inst1_rs2];
						} else {
							/* Use value inside ROB */
							issue_inst1_Vk = rob.read_operandD_val;
							issue_inst1_Qk = 0;
						}
					} else {
						issue_inst1_Vk = gpr.readD(issue_inst1_rs1);
						issue_inst1_Qk = 0;
					}
				}
			} else if(issue_inst1_rs2_sel == RS_SEL_IMM) {
				issue_inst1_Vk = issue_inst1_imm;
				issue_inst1_Qk = 0;
			}
			rob.push(
				issue_fetch_packet.valid0, issue_fetch_packet.pc0, issue_fetch_packet.inst0, issue_inst0_rd,
				issue_fetch_packet.valid1, issue_fetch_packet.pc1, issue_fetch_packet.inst1, issue_inst1_rd
			);
			alu_rs1.issue(
				issue_fetch_packet.valid0, issue_inst0_op, issue_inst0_Vj, issue_inst0_Vk, issue_inst0_Qj, issue_inst0_Qk, rob.tag, 0
			);
			alu_rs0.issue(
				issue_fetch_packet.valid1, issue_inst1_op, issue_inst1_Vj, issue_inst1_Vk, issue_inst1_Qj, issue_inst1_Qk, rob.tag+1, 0
			);
			/* inst0 rd mapping */
			if(issue_inst0_rd != 0) {
				register_map_table[issue_inst0_rd] := rob.tag;
				register_status_table[issue_inst0_rd] := BUSY;
			}
			/* inst1 rd mapping */
			if(issue_inst1_rd != 0) {
				register_map_table[issue_inst1_rd] := rob.tag+1;
				register_status_table[issue_inst1_rd] := BUSY;
			}
			finish();
		} else {
			stall_issue();
		}
	}
	func alu_rs0.dispatch {
		execute_alu0.invoke(alu_rs0.dispatch_Op, alu_rs0.dispatch_Dest, alu_rs0.dispatch_Vj, alu_rs0.dispatch_Vk);
	}
	func alu_rs1.dispatch {
		execute_alu1.invoke(alu_rs1.dispatch_Op, alu_rs1.dispatch_Dest, alu_rs1.dispatch_Vj, alu_rs1.dispatch_Vk);
	}
	proc execute_alu0 {
		alu32 alu0;

		alu0.exe(execute_alu0_a, execute_alu0_b, execute_alu0_fn);
		writeresult_alu0(execute_alu0_dest, alu0.q);
	}
	proc execute_alu1 {
		alu32 alu1;

		alu1.exe(execute_alu1_a, execute_alu1_b, execute_alu1_fn);
		writeresult_alu1(execute_alu1_dest, alu1.q);
	}
	proc writeresult_alu0 {
		alu_rs0.CDB0(writeresult_alu0_dest, writeresult_alu0_val);
		alu_rs1.CDB0(writeresult_alu0_dest, writeresult_alu0_val);
		rob.CDB0(writeresult_alu0_dest, writeresult_alu0_val);
		finish();
	}
	proc writeresult_alu1 {
		alu_rs0.CDB1(writeresult_alu1_dest, writeresult_alu1_val);
		alu_rs1.CDB1(writeresult_alu1_dest, writeresult_alu1_val);
		rob.CDB1(writeresult_alu1_dest, writeresult_alu1_val);
		finish();
	}
	func rob.commit {
		if(issue && (issue_inst0_rd != rob.commit_Dest0)) {
			register_status_table[rob.commit_Dest0] := READY;
		}
		if(issue && (issue_inst1_rd != rob.commit_Dest1)) {
			register_status_table[rob.commit_Dest1] := READY;
		}
		gpr.writeA(rob.commit_Dest0, rob.commit_Value0);
		gpr.writeB(rob.commit_Dest1, rob.commit_Value1);
	}

	WISHBONE_MASTER_IF(ifu);
}
