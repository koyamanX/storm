#include "reservation_station_in_order.h"
#include "reservation_station_entry.h"

module reservation_station_in_order {
    reservation_station_entry rs[NUMBER_OF_RS_IN_ORDER];
    reg tail[LOG2_RS_IN_ORDER_NUM_OF_ENTRIES+1] = 0;
    reg head[LOG2_RS_IN_ORDER_NUM_OF_ENTRIES+1] = 0;
    wire next_tail[LOG2_RS_IN_ORDER_NUM_OF_ENTRIES+1];
    wire next_head[LOG2_RS_IN_ORDER_NUM_OF_ENTRIES+1];
    integer i_;
    reservation_station_entry_t wire dispatch_entry;

    next_tail = tail + 1;
    next_head = head + 1;

    func issue {
        wire issue_Qj[ROB_TAG_SIZE];
        wire issue_Qk[ROB_TAG_SIZE];
        wire issue_Vj[32];
        wire issue_Vk[32];

        /* Bypass */
        any {
            CDB0 && (Qj == CDB0Id) && Valid: {issue_Vj = CDB0Val; issue_Qj = 0;}
            CDB1 && (Qj == CDB1Id) && Valid: {issue_Vj = CDB1Val; issue_Qj = 0;}
            CDB2 && (Qj == CDB2Id) && Valid: {issue_Vj = CDB2Val; issue_Qj = 0;}
            CDB3 && (Qj == CDB3Id) && Valid: {issue_Vj = CDB3Val; issue_Qj = 0;}
            else: {
                issue_Qj = Qj;
                issue_Vj = Vj;
            }
        }
        any {
            CDB0 && (Qk == CDB0Id) && Valid: {issue_Vk = CDB0Val; issue_Qk = 0;}
            CDB1 && (Qk == CDB1Id) && Valid: {issue_Vk = CDB1Val; issue_Qk = 0;}
            CDB2 && (Qk == CDB2Id) && Valid: {issue_Vk = CDB2Val; issue_Qk = 0;}
            CDB3 && (Qk == CDB3Id) && Valid: {issue_Vk = CDB3Val; issue_Qk = 0;}
            else: {
                issue_Qk = Qk;
                issue_Vk = Vk;
            }
        }
        if(!flush) {
            generate(i_ = 0; i_ < NUMBER_OF_RS_IN_ORDER; i_++) {
                if(tail[LOG2_RS_IN_ORDER_NUM_OF_ENTRIES-1:0] == i_) rs[i_].issue(Valid, Op, issue_Vj, issue_Vk, issue_Qj, issue_Qk, Dest, A);
            }
            tail := next_tail;
        }
    }
    func flush {
        generate(i_ = 0; i_ < NUMBER_OF_RS_IN_ORDER; i_++) {
            rs[i_].flush();
        }
        head := 0;
        tail := 0;
    }
    func CDB0 {
        if(!flush) {
            generate(i_ = 0; i_ < NUMBER_OF_RS_IN_ORDER; i_++) {
                rs[i_].CDB0(CDB0Id, CDB0Val);
            }
        }
    }
    func CDB1 {
        if(!flush) {
            generate(i_ = 0; i_ < NUMBER_OF_RS_IN_ORDER; i_++) {
                rs[i_].CDB1(CDB1Id, CDB1Val);
            }
        }
    }
    func CDB2 {
        if(!flush) {
            generate(i_ = 0; i_ < NUMBER_OF_RS_IN_ORDER; i_++) {
                rs[i_].CDB2(CDB2Id, CDB2Val);
            }
        }
    }
    func CDB3 {
        if(!flush) {
            generate(i_ = 0; i_ < NUMBER_OF_RS_IN_ORDER; i_++) {
                rs[i_].CDB3(CDB3Id, CDB3Val);
            }
        }
    }
    if(!flush && !stall) {
        generate(i_ = 0; i_ < NUMBER_OF_RS_IN_ORDER; i_++) {
            if((head[LOG2_RS_IN_ORDER_NUM_OF_ENTRIES-1:0] == i_) && rs[i_].dispatchable) {
                dispatch_entry = rs[i_].dispatch();
                dispatch(dispatch_entry.Op, dispatch_entry.Dest, dispatch_entry.Vj, dispatch_entry.Vk, dispatch_entry.A);
                head := next_head;
            }
        }
    }
    if(!flush) {
        if((tail[LOG2_RS_IN_ORDER_NUM_OF_ENTRIES-1:0] == head[LOG2_RS_IN_ORDER_NUM_OF_ENTRIES-1:0])
            && (tail[LOG2_RS_IN_ORDER_NUM_OF_ENTRIES] != head[LOG2_RS_IN_ORDER_NUM_OF_ENTRIES])) {
            full();
        }
    }
}
